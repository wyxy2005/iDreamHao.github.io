<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雨缠禅的博客</title>
  
  <subtitle>不以自身的好恶去评判他人和事物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://datalearn.top/"/>
  <updated>2018-08-18T01:52:45.882Z</updated>
  <id>http://datalearn.top/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写给工程师的十条精进原则</title>
    <link href="http://datalearn.top/2018/08/17/meituan/"/>
    <id>http://datalearn.top/2018/08/17/meituan/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2018-08-18T01:52:45.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>时间回到8年前，我人生中第一份实习的工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线就写了人生中第一个Casestudy。由于对部署环境的不了解，把SVN库里的配置文件错误地发到线上，并且上完线就去吃晚饭了，等吃饭回来发现师傅在焦头烂额地回滚配置。那次故障造成了一个核心服务20分钟不可用，影响了几百万的用户。这仅仅是一个开始，在后来半年的时间里，我几乎把所有职场新人可能犯的错误都犯了个遍。架构师让我调研一个抓取性能提升方案，我闷头搞了两周，也没有得出任何结论；本来安排好的开发计划，由于我临时要回去写论文，搞得经理措手不及；参加项目座谈会，全程“打酱油”……那段时间，自己也很苦恼，几乎每天晚上11点多才走，很累很辛苦，但依然拿不到想要的结果。<br>8年过去了，自己从一个职场小白逐步成长为一名技术Leader。我发现团队中的很多同学在不停地重复犯着自己当年类似的错误。他们并不是不努力，到底是哪里出了问题？经过一段时间的观察与思考后，我想我找到了答案。那就是：我们大多数同学在工作中缺乏原则的指导。原则，犹如指引行动的“灯塔”，它连接着我们的价值观与行动。不久前，桥水基金创始人雷·达里奥在《原则》一书中所传达的理念，引爆了朋友圈。每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。但是在现实生活中，我们往往缺少对原则的总结，对于很多人来说这是一门“只可意会不可言传”的玄学，是属于老司机的秘密，其实不然。<br>“追求卓越”是美团的价值观。作为一名技术人员，我们应该如何践行呢？本文总结了十条精进原则，希望能够给大家带来一些启发，更好地指导我们的行动。</p><h3 id="原则一：Owner意识"><a href="#原则一：Owner意识" class="headerlink" title="原则一：Owner意识"></a>原则一：Owner意识</h3><p>“Owner意识”主要体现在两个层面：一是认真负责的态度，二是积极主动的精神。<br>认真负责是工作的底线。首先，要对我们交付的结果负责。项目中每一个设计文档、每一行代码都需要认真完成，要对它的质量负责。如果设计文档逻辑混乱，代码没有注释，测试时发现一堆Bug，影响的不仅仅是RD的工程交付质量，还会对协同工作的RD、QA、PM等产生不好的影响。久而久之，团队的整体交付质量、工作效率也会逐步下降，甚至会导致团队成员之间产生不信任感。其次，我们要对开发的系统负责。系统的架构是否需要改进，接口文档是否完善，日志是否完整，数据库是否需要扩容，缓存空间够不够等等，这些都是需要落地的事情。作为系统Owner，请一定要认真履行。<br>积极主动是“Owner意识”更高一级的要求。RD每天要面对大量的工作，而且很多并不在计划内，这就需要具备一种积极主动的精神。例如我们每天可能会面对大量的技术咨询，如果客户提出的问题很长时间得不到回应的话，就会带来不好的客户体验。很多同学说忙于自己的工作没有时间处理，有同学觉得这件事不是很重要，也有很多同学是看到了，但是不知道怎么回答，更有甚者，看到了干脆装没看见。这些都是缺乏Owner意识的体现。正确的做法是积极主动地推动问题的解决，如果时间无法排开或者不知道如何解决，可以直接将问题反馈给能解决的同学。积极主动还可以表现在更多方面。比如很多同学会自发地梳理负责服务的现状，根据接口在性能方面暴露的问题提出改进意见并持续推动解决；也有同学在跨团队沟通中主动承担起主R的角色，积极发现问题、暴露问题，推动合作团队的进度，保证项目顺利推进。这些同学无一不是团队的中坚力量。所以，我们在做好自己份内工作的同时，也应该积极主动地投入到“份外”的工作中去。一分耕耘一分收获，不要给自己设限，努力成为一个更加优秀的人。</p><h3 id="原则二：时间观念"><a href="#原则二：时间观念" class="headerlink" title="原则二：时间观念"></a>原则二：时间观念</h3><p>相信大家都有时间观念，但是真正能执行到位的可能并没有那么多。互联网是一个快速发展的行业，RD的研发效率是一个公司硬实力的重要体现。项目的按期交付是一项很重要的执行能力，在很大程度上决定着领导和同事对自己靠谱程度的评价。大家可能会问：难度几乎相同的项目，为什么有的同学经常Delay，而有的同学每次都能按时上线？一个很重要的原因，就是这些按时交付的同学往往具备如下两个特质：做事有计划，工作分主次。<br>工作安排要有计划性。通常，RD在设计评审之后就能预估出精确的开发时间，进而再合理地安排开发、联调、测试计划。如果是项目负责人，那么就会涉及协调FE、QA、PM等多个工种的同学共同完成工作。凡事预则立，不预则废。在计划制定过程中，要尽可能把每一项拆细一点（至少到pd粒度）。事实证明，粒度越细，计划就越精准，实际开发时间与计划之间的误差就会越小。此外，务必要规定明确的可检查的产出，并在计划中设置一些关键的时间点进行核对。无数血淋淋的事实告诉我们，很多项目延期都是因为在一些关键交付点上双方存在分歧造成的。例如后台RD的接口文档计划在周五提供，FE认为是周五上午，而RD认为是周五下班前提交，无形中会给排期带来了1pd的误差。所以，我们要做到计划粒度足够细，关键时间点要可检查。<br>工作安排要分清楚主次。我们每天要面对很多的事情，要学会分辨这些工作的主次。可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。很多项目无法按期交付的原因，都是因为执行人分不清主次。比如在开发中需要使用到ES，一些不熟悉ES的同学可能想系统性地学习一下这方面的知识，就会一头扎进ES的汪洋中。最后才发现，原本一天就能完成的工作被严重拖后。实际工作中，我们应当避免这种“本末倒置”的工作方式。在本例中，“系统性地学习ES”是一件重要但不紧急的事情。要学会分辨出这些干扰的工作项，保证重要紧急的事情能够按时交付。</p><h3 id="原则三：以终为始"><a href="#原则三：以终为始" class="headerlink" title="原则三：以终为始"></a>原则三：以终为始</h3><p>“以终为始”（Begin With The End In Mind），是史蒂芬·柯维在《高效能人士的七个习惯》中提到的一个习惯。它是以所有事物都经过两次创造的原则（第一次为心智上的创造，第二次为实际的创造）为基础的。直观的表达就是：先想清楚目标，然后努力实现。<br>在工作中，很多RD往往只是埋头走路，很少抬头看天。每次季度总结的时候，罗列了很多项目，付出很多努力。但是具体这些项目取得了哪些收益，对业务有哪些提升，却很难说出来。这就说明在工作中并没有遵守“以终为始”这一原则。此外，很多同学在做需求的过程中，对于目标与收益关注不够，系统上线之后，也没有持续地跟进使用效果。这一点在技术优化项目中体现得尤为明显。例如在一个接口性能优化的项目中，经过RD的努力优化，系统TP99缩短了60%，支持QPS提升了2倍。但是系统到底需要优化到什么程度呢？是不是缩短60%，提升2倍就能满足需求呢？在优化之前，很多同学常常忘记设置一个预设的目标（TP99小于多少，支持QPS大于多少）。我们必须清楚，优化一定是有原因的，比如预期某节假日流量会暴增或者某接口超时比例过高，如果不进行优化，系统可能会存在宕机风险。解决特定的问题才是技术优化的最终目的，所以要根据问题设定目标，再进行优化。<br>“以终为始”，这一原则还可以作用于我们的学习中。很多同学看过很多技术文章，但是总是感觉自己仍然一无所知。很重要的一个原因，就是没有带着目标去学习。在这个信息爆炸的时代，如果只是碎片化地接收各个公众号推送的文章，效果几乎可以忽略不计。在学习之前，我们一定要问自己，这次学习的目标是什么？是想把Redis的持久化原理搞清楚，还是把Redis的主从同步机制弄明白，亦或是想学习整个Redis Cluster的架构体系。如果我们能够带着问题与目标，再进行相关的资料搜集与学习，就会事半功倍。这种学习模式的效果会比碎片化阅读好很多。</p><h3 id="原则四：闭环思维"><a href="#原则四：闭环思维" class="headerlink" title="原则四：闭环思维"></a>原则四：闭环思维</h3><p>你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。<br>之前看过一句话：一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。这就是闭环思维的重要性。它强调的是一种即时反馈闭环，如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。例如在跨部门的沟通会议中，虽然各方达成了一致，会议发起者已经将最终的记录周知大家。但是，到这一步其实并没有完成真正的闭环，在落地执行过程中很可能还存在一些潜在的问题。例如，会议纪要是否经各方仔细核对并确认过？会议中明确的To Do进展是什么？完成结果有没有Check的机制？如果这些没有做到的话，就会陷入“沟通-发现问题-再沟通-再发现问题”的恶性循环中。真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。<br>“闭环思维”还要求能够定期主动进行阶段性的反馈。刚参加工作时，我接了一个工期为两个月的项目。整个项目需要独自完成，自己每天按照计划，有条不紊地进行开发。大概过了两周之后，Leader询问项目进度，虽然我已经跟他说没问题。然而，Leader告诉我，因为我每天对着电脑也不说话，让他心里很没底。这时，我才意识到一个很重要的问题，我跟Leader之间存在信息不对称。从那以后，我就时不时得跟他汇报一下进度，哪怕就只有简短的一句话，也可以明显感觉，他对我的信心增加了很多。特别是我做Leader之后，对这种闭环反馈的理解，就更加深刻了。从Leader的角度看，其实只是想知道项目是否在正常推进，是否遇到问题需要他协助解决。</p><h3 id="原则五：保持敬畏"><a href="#原则五：保持敬畏" class="headerlink" title="原则五：保持敬畏"></a>原则五：保持敬畏</h3><p>“君子之心，常怀敬畏”，保持敬畏之心能够让我们少犯错误。在工作中存在各种各样的规范，例如代码规范、设计规范、上线规范等等。我们必须明白，这些规范的制定一定是基于某些客观原因的，它们都是历史上无数Case积累而来的经验。团队里的每一个成员都应该学习并严格遵守，这一点对于新人尤其重要。<br>当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。以编码风格为例，很多同学往往习惯于自己之前的代码写作风格，在做新公司第一个项目时，也按照自己的习惯进行变量、包的命名等等。结果在代码Review过程中，被提了很多修改意见，不得不返工重写，得不偿失。如果能够保持敬畏之心，提前了解编码规范，这种问题完全可以避免。类似的问题，还包括对上线流程不了解，对回滚操作不熟悉，对SRE线上变更过程不了解等等。除了这些显而易见的规范，还有一些约定俗成的规则。个人建议是：如果有事情拿不准，不妨多问问其他同事，不要凭自己的感觉做事情。<br>保持敬畏之心并不意味着要“因循守旧”。在我们充分了解这些规范和约定之后，如果觉得存在不妥之处，可以跟全组同学讨论，是否采纳新的建议，然后及时去更新迭代。其实，让规范与约定与时俱进，也是另一种形式的敬畏。</p><h3 id="原则六：事不过二"><a href="#原则六：事不过二" class="headerlink" title="原则六：事不过二"></a>原则六：事不过二</h3><p>“事不过二”，是我们团队一贯坚持的原则，它可以解读为两层含义。<br>一层含义是<strong>“所有的评审与问题讨论，不要超过两次”</strong>。之所以有这样的要求，是因为我们发现，很多RD都把时间花费在一些无休止的评审与问题讨论中，真正投入到实际开发中的时间反而很少。在实际工作场景中，我们经常会遇到一些不是很成熟的需求评审。这些需求文档，要么是背景与目标含糊不清，要么是产品方案描述不够细化，或者存在歧义。RD与PM被迫反复进行讨论，我曾经遇到过一个需求评审，进行了三次还被打回。同样的问题，在设计评审中也屡见不鲜。方案固然需要经过反复的讨论，但是如果迟迟不能达成一致，就会耗费很多RD与PM的宝贵时间，这就与提升研发效率的理念背道而驰。因此，我们团队规定：<strong>所有的评审最多两次。</strong>通过这种方式，倒逼利益相关方尽可能地做好需求与方案设计。评审会议组织前，尝试与所有相关人员达成一致，询问对方的意见，并进行有针对性的讨论，这样能够大大提升评审会议的效率和质量。如果在第一次评审中不通过，那么就只有一次机会进行复审。一旦两次不通过，就需要进行Casestudy。<br>“事不过二”原则的另一层含义，是“同样的错误不能犯第二次”。每次故障之后，Casestudy都必须进行深刻的总结复盘，对故障原因进行5Why分析，给出明确可执行的To Do List。每次季度总结会，大家自我反省问题所在，在下个季度必须有所改善，不能再犯类似的错误。孔子云：“不迁怒，不贰过”，在错误中反思与成长，才能让我们成为更优秀的人。</p><h3 id="原则七：设计优先"><a href="#原则七：设计优先" class="headerlink" title="原则七：设计优先"></a>原则七：设计优先</h3><p>“设计优先”这条原则，相对来说更加具体一些。之所以单列一项，是因为架构设计太重要了。Uncle Bob曾说过：“软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。”<br>架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。很多团队也有明文规定，开发周期在3pd以上的项目必须有设计文档，开发周期在5pd以上的项目必须有设计评审。在具体的执行过程中，由于各种原因，设计往往并不能达到预期的效果。究其原因，有的是因为项目周期紧，来不及设计得足够详细；有的是因为RD主观上认为项目比较简单，设计草草了事。无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。因此，无论什么时候都要记住“设计优先”这一原则。磨刀不误砍柴工，前期良好的设计，会给项目开发以及后期维护带来极大的收益。<br>“设计优先”这一原则，要求写别人看得懂的设计。我们了解一个系统最直接的途径就是结合设计文档与代码。在实际工作中，很多同学的设计文档让大家看得一头雾水，通篇下来，看不出系统整体的设计思路。其实，设计的过程是一种智力上的创造，我们更希望它能成为个人与集体智慧的结晶。如何才能让我们的设计变得通俗易懂？我个人认为，设计应该尽量使用比较合理的逻辑，进而把设计中的一些点组织起来。比如可以使用从抽象到具体，由总到分的结构来组织材料。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。</p><h3 id="原则八：P-PC平衡"><a href="#原则八：P-PC平衡" class="headerlink" title="原则八：P/PC平衡"></a>原则八：P/PC平衡</h3><p>“P/PC平衡”原则，即产出与产能平衡原则。伊索寓言中讲述了一个《生金蛋的鹅》的故事。产出好比“金蛋”，产能好比“会下金蛋的鹅”。“重蛋轻鹅”的人，最终可能连产蛋的资产都保不住；“重鹅轻蛋”的人，最终可能会被饿死。产出与产能必须平衡，才能达到真正的高效能。为了让大家更清晰的了解这一原则，本文举两个例子。<br>从系统的角度看，每一个系统都是通过持续不断地叠加功能来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。如果一味地做业务需求，经过一定的时间，系统会越来越慢，最终影响业务的稳定性；反之，一个没有任何业务产出的系统，最终会消亡。<br>再从RD的角度来看这个问题，RD通过做需求来给公司创造价值，实现自己的产出。而RD的产能是指技术能力、软素质、身体健康状况，有这些资本后，我们才能进行持续的产出。在日常工作中，我发现很多RD往往只重视产出。他们也在很努力地做项目，但是每一个项目所使用的方法，还是沿用自己先前一贯的思路。最终，不仅项目做得一般，还会抱怨自己得不到任何成长。这就是P/PC不平衡的体现。如果能在做项目的过程中，通过学习总结持续提升自己的技术能力和软素质，并将其应用于项目实施交付中，相信一定会取得双赢的结果。<br>“P/PC平衡”原则还适用于很多其他的领域，例如团队、家庭等，我本人也非常推崇这一原则。希望大家也能将其作为自身的一项基本原则，努力寻找到产出与产能的平衡点。</p><h3 id="原则九：善于提问"><a href="#原则九：善于提问" class="headerlink" title="原则九：善于提问"></a>原则九：善于提问</h3><p>“善于提问”，首先要勤于提问。求知欲源于好奇心，是人类的一种本能。在工作中要养成勤于提问的好习惯，不懂就问，不要因为自己一时懒惰或者碍于情面，就放弃提问的机会。当遇到不同的观点时，也要礼貌地问出来。波克定理告诉我们，只有在争辩中，才可能诞生最好的主意和最好的决定。<br>在设计评审、代码评审这类体现集体智慧的活动中，遇到有问题的地方一定要提出来。我经常看到，很多同学评审全程一言不发，这就是浪费大家的时间。设计评审的目的，是让大家针对方案提出改进意见并达成一致，如果全程“打酱油”，那就失去了评审的意义。我们鼓励大家多提问，把自己内心的疑惑表达出来，然后通过交流的方式得到答案。<br>“善于提问”，还要懂得如何提问。为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：批判性思维。<br>批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。同样，在阅读一篇技术博客的时候，也要使用批判性的思维，多问几个为什么，作者得出的结论是否合理？论据是否充分？只有这样，才能不断地获取真正的知识。</p><h3 id="原则十：空杯心态"><a href="#原则十：空杯心态" class="headerlink" title="原则十：空杯心态"></a>原则十：空杯心态</h3><p>“满招损，谦受益”，“空杯心态”是最后一项原则。我觉得这也是一个人能够持续成长的前提。做技术的人，骨子里通常有股傲气，并且会随着资历、成绩的提升而不断增加。初入职场的小白，可能会非常谦虚，但是工作几年之后，专业技能逐步提升，可能还取得了一些小成就，人就会越来越自信。这时候，如果不能始终保持“空杯心态”，这种自信就会逐步演变为自满。自满的人，往往表现为工作中把别人的建议当成是批评，不接受任何反对意见，学习上也缺乏求知的动力，总是拿自己的长处去跟别人的短处做比较。其实每个人多少都会有一些自满，可怕的是不知道甚至不愿承认自满。<br>保持“空杯心态”这一原则要求我们时刻进行自我检视与反省。在工作中，多去跟不同级别的同学聊一聊，或者做一个360度评估，这有助于我们更加客观地评价自己。在横向对比中，多向那些优秀的同学看齐，学习他人的优点。很多同学在设计评审或者代码review过程中，针对别人提出的问题与建议，往往都采用一种对立的态度。错误地认为别人是在挑刺，是在针对自己。诚然，在某些方面，我们可能确实比其他人想得深入，但是这不代表在所有方面都能考虑周全。对于别人的建议，建议使用“善于提问”原则里提到的批判性思维仔细分析一下，虚心地吸取那些好的建议。<br>工作学习就像“练级打怪”，技能储备的越多，就越容易走到最后。保持空杯心态，可以让我们发现很多以前注意不到的新能力，我们要做的就是努力学习它，将它们转化为自己能力库的一部分。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上，是我总结的工作与学习的十条基本原则。其中有的侧重于个人做事情的方法，如“Owner意识”、“时间观念”、“以终为始”、”闭环思维”；有的侧重于团队工作标准规范，如“保持敬畏”、“事不过二”、“设计优先”；有的侧重于团队或个人效能提升，如“P/PC平衡”、“善于提问”、“空杯心态”。这些原则是我多年在工作与学习中，不断总结得来的经验。希望在大家面临选择时，这些原则能够起到一定的帮助和指导作用。<br>以原则为中心地工作与生活，让自己与团队变得更加强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;时间回到8年前，我人生中第一份实习的工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线
      
    
    </summary>
    
      <category term="编程技术" scheme="http://datalearn.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>美如画的高分纪录片《极地》分享</title>
    <link href="http://datalearn.top/2018/07/28/jidi/"/>
    <id>http://datalearn.top/2018/07/28/jidi/</id>
    <published>2018-07-27T16:00:00.000Z</published>
    <updated>2018-07-30T16:32:03.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>《极地》运用了电影般诗意的叙事语言，从普通人的爱与感情出发，展现了西藏人的生活日常。既考察极端环境下的生存智慧，也呈现普通人的生活，既探究古老文化的精髓，也记录西藏的当下。在展现广阔高原壮美自然风光中，捕捉人们日常生活的种种细节，展现出一幅史诗般的高原生活图卷。<br>《极地》不仅考察了在极端环境下的生存智慧，还呈现出来自普通人的生活，既探究了古老文化的精髓，也记录了西藏的当下。在展现广阔高原壮美自然风光中，同样捕捉了人们日常生活的种种细节。<br>需要订阅博主可以点击 <a href="http://i.youku.com/dreamhaolove" target="_blank" rel="noopener">订阅</a></p><h3 id="第一集"><a href="#第一集" class="headerlink" title="第一集"></a>第一集</h3><h5 id="孤独土地上的守望者"><a href="#孤独土地上的守望者" class="headerlink" title="孤独土地上的守望者"></a>孤独土地上的守望者</h5><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>荒原，森林，雪地。他们在这片孤独的土地上守望着，也创造快乐。人与自然既博弈也交融。在世界海拔最高的草原-羌塘无人区，野保员多吉次巴守卫动物，保护自己的家；在波密夏季的暴雨后，流动电影放映员白玛与马一起悬索渡江，只为给村民带去两小时的电影时光；在年均气温零下五度的双湖，60多岁的次仁旺青以日月风雪为伴，带队驮盐。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzczOTQyNDc1Mg==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><h3 id="第二集"><a href="#第二集" class="headerlink" title="第二集"></a>第二集</h3><h5 id="走进高原人的世界"><a href="#走进高原人的世界" class="headerlink" title="走进高原人的世界"></a>走进高原人的世界</h5><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>隐秘于波密森林中的八盖乡，村民们还在使用木锁。这批锁已经损耗得差不多了，可锁匠江安发誓不再打铁，现在该怎么办呢？在年日照超过3000小时的札达，三位奶奶有对抗烈日有独特的办法；降雨量超过800毫米的察隅山区，僜人爷爷大佰龙一直在等待儿子的归来。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzc0NjE4NjY2MA==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><h3 id="第三集"><a href="#第三集" class="headerlink" title="第三集"></a>第三集</h3><h5 id="守护极地即将失传的手艺"><a href="#守护极地即将失传的手艺" class="headerlink" title="守护极地即将失传的手艺"></a>守护极地即将失传的手艺</h5><h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><p>在与自然的对抗中，生存的手段逐渐转变成为了独特的庆典和赛事。极地人用竞技和仪式将生存技能赋予了新的意义，用狂欢的姿态展示着文明和力量。<br>乌尔朵的制作方式正面临失传，边巴是乌尔朵编织技艺最娴熟的人，他想举办一场比赛，来唤起年轻人对它的兴趣；每年一度的赛马是日土的风俗，今年，是洛桑成年后第一次参加赛马；81岁的赤来伦珠一直是桑央节上谐钦舞的领舞，他知道，这是他最后一次参加桑央节了。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzc0NTQ2ODgwOA==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><h3 id="第四集"><a href="#第四集" class="headerlink" title="第四集"></a>第四集</h3><h5 id="不可推卸的使命"><a href="#不可推卸的使命" class="headerlink" title="不可推卸的使命"></a>不可推卸的使命</h5><h5 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h5><p>在极地，“简单”是人与人之间关系的核心。而拥有手艺的人还承载着托付。占堆是远近闻名的说浑人，常常对着纳木错歌唱颂词，这一次，他将骑马去为新人说婚；扎西佳培是一把孤刀，洛桑顿珠成为了它今后的伴侣；拉索扎西一辈子都在帮寺院做面具，可他觉得这手艺并不属于自己，它依附于一个更强大的力量，这种力量赋予他不可推卸的使命。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzczOTg2NDc4MA==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><h3 id="第五集"><a href="#第五集" class="headerlink" title="第五集"></a>第五集</h3><h5 id="幸福的智慧西藏"><a href="#幸福的智慧西藏" class="headerlink" title="幸福的智慧西藏"></a>幸福的智慧西藏</h5><h5 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h5><p>为什么说西藏拥有幸福？因为他们有大智慧。敬畏自然、自力更生、帮助他人，这是融入了生活的的智慧。藏医贡觉仁增在村子里很受尊敬，这次，他又带着药和药浴桶翻山越岭去行医了；格拉丹东雪山下降临了一个新生命，迪迪希望每一个孩子都能像他一样敬畏神山；多吉扎巴是藏北牧鞋的传承人，为了推广牧鞋，他带着八双鞋来到了拉萨。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzc0MDA1ODEzMg==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><h3 id="第六集"><a href="#第六集" class="headerlink" title="第六集"></a>第六集</h3><h5 id="高原上的传承"><a href="#高原上的传承" class="headerlink" title="高原上的传承"></a>高原上的传承</h5><h5 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h5><p>传承最核心的部分是传授的过程。次旺多吉当了36年的藏戏团团长，他在巡演途中不停磨练着儿子的藏戏，75岁的他还要一直唱下去；琼珠掌握着藏族一种神奇的诊疗方式。他对病人的牵挂，是这片荒原之中的温暖依靠；平措扎西是一个壁画画师，他一年之中大部分时间都在寺院画画，这次，他带领着徒弟们来到噶举寺，义务为寺庙画了一幅白伞金刚。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzc0NjU3MDAwOA==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><h3 id="第七集"><a href="#第七集" class="headerlink" title="第七集"></a>第七集</h3><h5 id="西藏的年轻人"><a href="#西藏的年轻人" class="headerlink" title="西藏的年轻人"></a>西藏的年轻人</h5><h5 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h5><p>西藏的年轻人是什么样子？他们既传承民族的文化，也传达着自我。解放和曲珍经营着一个民间舞团，他们的舞团正在为赛马节排练；单增曲杰是墨脱县加热萨乡小学的老师，一部钢琴怎么才能进入这个高原孤岛？边巴扎西为古老的文布南村立了一块广告牌，他用微笑搭建了一座与外界沟通的桥梁。</p><hr><embed src="http://player.youku.com/player.php/sid/XMzc0NzU5MTM0NA==/v.swf" allowfullscreen="true" quality="high" width="910" height="550" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;《极地》运用了电影般诗意的叙事语言，从普通人的爱与感情出发，展现了西藏人的生活日常。既考察极端环境下的生存智慧，也呈现普通人的生活，既探究古
      
    
    </summary>
    
      <category term="影视分享" scheme="http://datalearn.top/categories/%E5%BD%B1%E8%A7%86%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="纪录片" scheme="http://datalearn.top/tags/%E7%BA%AA%E5%BD%95%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>移动端页面常见bug及解决方案</title>
    <link href="http://datalearn.top/2018/05/17/mobile001/"/>
    <id>http://datalearn.top/2018/05/17/mobile001/</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:58.880Z</updated>
    
    <content type="html"><![CDATA[<p>本文是摘录整理了移动端H5页面常见的一些bug以及解决方案，后期还会有更新</p><h3 id="点击样式闪动"><a href="#点击样式闪动" class="headerlink" title="点击样式闪动"></a>点击样式闪动</h3><p>Q: 当你点击一个链接或者通过Javascript定义的可点击元素的时候，它就会出现一个半透明的灰色背景。<br>A:根本原因是-webkit-tap-highlight-color，这个属性是用于设定元素在移动设备（如Adnroid、iOS）上被触发点击事件时，响应的背景框的颜色。建议写在样式初始化中以避免所以问题：div,input(selector) {-webkit-tap-highlight-color: rgba(0,0,0,0);}另外出现蓝色边框：outline:none；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-webkit-tap-highlight-color : rgba (255, 255, 255, 0) ;</span><br><span class="line">// i.e . Nexus5/Chrome and Kindle Fire HD 7 &apos;&apos;</span><br><span class="line">-webkit-tap-highlight-color : transparent ;</span><br></pre></td></tr></table></figure><h3 id="屏蔽用户选择"><a href="#屏蔽用户选择" class="headerlink" title="屏蔽用户选择"></a>屏蔽用户选择</h3><p>Q: 禁止用户选择页面中的文字或者图片<br>A:代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-webkit-touch-callout: none;</span><br><span class="line">-webkit-user-select: none;</span><br><span class="line">-khtml-user-select: none;</span><br><span class="line">-moz-user-select: none;</span><br><span class="line">-ms-user-select: none;</span><br><span class="line">user-select: none;</span><br></pre></td></tr></table></figure><h3 id="移动端如何清除输入框内阴影"><a href="#移动端如何清除输入框内阴影" class="headerlink" title="移动端如何清除输入框内阴影"></a>移动端如何清除输入框内阴影</h3><p>Q: 在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：<br>A:代码如下<br><code>-webkit-appearance: none;</code><br>禁止文本缩放<br>Q: 禁止文本缩放<br>A:代码如下<br>-webkit-text-size-adjust: 100%;</p><h3 id="如何禁止保存或拷贝图像"><a href="#如何禁止保存或拷贝图像" class="headerlink" title="如何禁止保存或拷贝图像"></a>如何禁止保存或拷贝图像</h3><p>Q: 如何禁止保存或拷贝图像<br>A:代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">-webkit-touch-callout: none;&#125;</span><br></pre></td></tr></table></figure><h3 id="解决字体在移动端比例缩小后出现锯齿的问题"><a href="#解决字体在移动端比例缩小后出现锯齿的问题" class="headerlink" title="解决字体在移动端比例缩小后出现锯齿的问题"></a>解决字体在移动端比例缩小后出现锯齿的问题</h3><p>Q: 解决字体在移动端比例缩小后出现锯齿的问题<br>A:代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-font-smoothing: antialiased;</span><br></pre></td></tr></table></figure><h3 id="设置input里面placeholder字体的大小"><a href="#设置input里面placeholder字体的大小" class="headerlink" title="设置input里面placeholder字体的大小"></a>设置input里面placeholder字体的大小</h3><p>Q: 设置input里面placeholder字体的大小<br>A:代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder&#123; font-size:10pt;&#125;</span><br></pre></td></tr></table></figure><h3 id="audio元素和video元素在ios和andriod中无法自动播放"><a href="#audio元素和video元素在ios和andriod中无法自动播放" class="headerlink" title="audio元素和video元素在ios和andriod中无法自动播放"></a>audio元素和video元素在ios和andriod中无法自动播放</h3><p>Q: audio元素和video元素在ios和andriod中无法自动播放<br>A:代码如下,触屏及播放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;html&apos;).one(&apos;touchstart&apos;,function()&#123;</span><br><span class="line">audio.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="手机拍照和上传图片"><a href="#手机拍照和上传图片" class="headerlink" title="手机拍照和上传图片"></a>手机拍照和上传图片</h3><p>Q: 针对file类型增加不同的accept字段<br>A:代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot;&gt;的accept 属性</span><br><span class="line">&lt;!-- 选择照片 --&gt;</span><br><span class="line">&lt;input type=file accept=&quot;image/*&quot;&gt;</span><br><span class="line">&lt;!-- 选择视频 --&gt;</span><br><span class="line">&lt;input type=file accept=&quot;video/*&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="输入框自动填充颜色"><a href="#输入框自动填充颜色" class="headerlink" title="输入框自动填充颜色"></a>输入框自动填充颜色</h3><p>Q: 针对input标签已经输入过的，会针对曾经输入的内容填充黄色背景，这是webkit内核自动添加的，对应的属性是autocomplete,默认是on,另对应的样式是input:-webkit-autofill 且是不可更改的。<br><img src="http://p3th9y4pk.bkt.clouddn.com/mobile0001.png" alt="mobile0001"><br>A:方案如下<br>1 设置标签的autocomplete=”off”,亲测无效可能<br>2 设置盒子的内阴影为你常态的颜色（下面以白色为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-shadow:0 0  0 1000px  #fff inset ;</span><br><span class="line">-webkit-box-shadow: 0 0 0px 1000px #fff inset;</span><br></pre></td></tr></table></figure><h3 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h3><p>Q: 优化渲染性能<br>A:代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-webkit-transform: translate3d(0, 0, 0);</span><br><span class="line">-moz-transform: translate3d(0, 0, 0);</span><br><span class="line">-ms-transform: translate3d(0, 0, 0);</span><br><span class="line">transform: translate3d(0, 0, 0);</span><br></pre></td></tr></table></figure><h3 id="用户设置字号放大或者缩小导致页面布局错误"><a href="#用户设置字号放大或者缩小导致页面布局错误" class="headerlink" title="用户设置字号放大或者缩小导致页面布局错误"></a>用户设置字号放大或者缩小导致页面布局错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body  </span><br><span class="line">    &#123;  </span><br><span class="line">        -webkit-text-size-adjust: 100% !important;  </span><br><span class="line">        text-size-adjust: 100% !important;  </span><br><span class="line">        -moz-text-size-adjust: 100% !important;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="移动端去除type为number的箭头"><a href="#移动端去除type为number的箭头" class="headerlink" title="移动端去除type为number的箭头"></a>移动端去除type为number的箭头</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input::-webkit-outer-spin-button,input::-webkit-inner-spin-button&#123;</span><br><span class="line">     -webkit-appearance: none !important;</span><br><span class="line">     margin: 0; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="实现横屏竖屏的方案"><a href="#实现横屏竖屏的方案" class="headerlink" title="实现横屏竖屏的方案"></a>实现横屏竖屏的方案</h3><h4 id="css-用-css3媒体查询，缺点是宽度和高度不好控制"><a href="#css-用-css3媒体查询，缺点是宽度和高度不好控制" class="headerlink" title="css 用 css3媒体查询，缺点是宽度和高度不好控制"></a>css 用 css3媒体查询，缺点是宽度和高度不好控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">    .main &#123;</span><br><span class="line">        -webkit-transform:rotate(-90deg);</span><br><span class="line">        -moz-transform: rotate(-90deg);</span><br><span class="line">        -ms-transform: rotate(-90deg);</span><br><span class="line">        transform: rotate(-90deg);</span><br><span class="line">        width: 100vh;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        /*去掉overflow 微信显示正常，但是浏览器有问题，竖屏时强制横屏缩小*/</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">    .main &#123;</span><br><span class="line">        -webkit-transform:rotate(0);</span><br><span class="line">        -moz-transform: rotate(0);</span><br><span class="line">        -ms-transform: rotate(0);</span><br><span class="line">        transform: rotate(0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="js-判断屏幕的方向或者resize事件"><a href="#js-判断屏幕的方向或者resize事件" class="headerlink" title="js 判断屏幕的方向或者resize事件"></a>js 判断屏幕的方向或者resize事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var evt = &quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;;</span><br><span class="line">    window.addEventListener(evt, function() &#123;</span><br><span class="line">        var width = document.documentElement.clientWidth;</span><br><span class="line">         var height =  document.documentElement.clientHeight;</span><br><span class="line">          $print =  $(&apos;#print&apos;);</span><br><span class="line">         if( width &gt; height )&#123;</span><br><span class="line"></span><br><span class="line">            $print.width(width);</span><br><span class="line">            $print.height(height);</span><br><span class="line">            $print.css(&apos;top&apos;,  0 );</span><br><span class="line">            $print.css(&apos;left&apos;,  0 );</span><br><span class="line">            $print.css(&apos;transform&apos; , &apos;none&apos;);</span><br><span class="line">            $print.css(&apos;transform-origin&apos; , &apos;50% 50%&apos;);</span><br><span class="line">         &#125;</span><br><span class="line">         else&#123;</span><br><span class="line">            $print.width(height);</span><br><span class="line">            $print.height(width);</span><br><span class="line">            $print.css(&apos;top&apos;,  (height-width)/2 );</span><br><span class="line">            $print.css(&apos;left&apos;,  0-(height-width)/2 );</span><br><span class="line">            $print.css(&apos;transform&apos; , &apos;rotate(90deg)&apos;);</span><br><span class="line">            $print.css(&apos;transform-origin&apos; , &apos;50% 50%&apos;);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, false);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是摘录整理了移动端H5页面常见的一些bug以及解决方案，后期还会有更新&lt;/p&gt;
&lt;h3 id=&quot;点击样式闪动&quot;&gt;&lt;a href=&quot;#点击样式闪动&quot; class=&quot;headerlink&quot; title=&quot;点击样式闪动&quot;&gt;&lt;/a&gt;点击样式闪动&lt;/h3&gt;&lt;p&gt;Q: 当你点击一个
      
    
    </summary>
    
      <category term="编程技术" scheme="http://datalearn.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>手机页面调试利器 – vConsole</title>
    <link href="http://datalearn.top/2018/05/07/vconsole/"/>
    <id>http://datalearn.top/2018/05/07/vconsole/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:59.744Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发手机版网页的时候，常常会出现下面的情景：<br>开发时，在自己电脑上运行得好好的，在手机上打开就挂了，但是手机上又看不到error log；<br>有时候上线后，某用户表示页面失灵，但我们自己又重现不出来，看不到用户侧的出错信息。<br>第一种情况还可以通过电脑连接手机以查看log来解决，后一种情况在没有完善的前端上报体系时就非常被动了。<br>那么一个轻量、可拓展、针对手机网页的前端开发者调试面板-vConsole就应运而生了。<br>首先它具备以下特性：</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies 和 localStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><h3 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h3><p>少废话，先来看效果<br>用手机扫描以下的二维码：<br><img src="http://p3th9y4pk.bkt.clouddn.com/vConsole1.png" alt="vConsole1"><br>打开页面后，你就可以看到一下的效果了<br><img src="http://p3th9y4pk.bkt.clouddn.com/vConsole2.png" alt="vConsole2"></p><h3 id="简单上手"><a href="#简单上手" class="headerlink" title="简单上手"></a>简单上手</h3><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 dist/vconsole.min.js）<br>当然推荐使用npm来安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>然后引入 dist/vconsole.min.js 到项目中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;path/to/vconsole.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 初始化</span><br><span class="line">  var vConsole = new VConsole();</span><br><span class="line">  console.log(&apos;引入成功&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h3><h4 id="下载模块"><a href="#下载模块" class="headerlink" title="下载模块"></a>下载模块</h4><p>下载 vConsole 的<a href="https://github.com/WechatFE/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。</p><br><p>或者使用 <code>npm</code> 安装：</p><br><pre><code>npm install vconsole<br></code></pre><br><p>然后复制 <code>dist/vconsole.min.js</code> 到自己的项目中。</p><h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><p>(1) 如果未使用 AMD/CMD 规范，可直接在 HTML 中引入 vConsole 模块。为了便于后续扩展，建议在 <code>&lt;head&gt;</code> 中引入：</p><br><div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">head</span>&gt;<br>  &lt;<span class="pl-ent">script</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">“</span>path/to/vconsole.min.js<span class="pl-pds">“</span></span>&gt;<span class="pl-s1">&lt;</span>/<span class="pl-ent">script</span>&gt;<br>  &lt;<span class="pl-ent">script</span>&gt;<span class="pl-s1"></span><br><span class="pl-s1">    <span class="pl-k">var</span> vConsole <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">VConsole</span>();</span><br><span class="pl-s1">  </span><span class="pl-s1">&lt;</span>/<span class="pl-ent">script</span>&gt;<br>&lt;/<span class="pl-ent">head</span>&gt;</pre></div><br><p>(2) 如果使用了 AMD/CMD 规范，可在 module 内使用 <code>require()</code> 引入模块：</p><br><div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> VConsole <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">‘</span>path/to/vconsole.min.js<span class="pl-pds">‘</span></span>);<br><span class="pl-k">var</span> vConsole <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">VConsole</span>();</pre></div><br><p>请注意，<code>VConsole</code> 只是 vConsole 的原型，而非一个已实例化的对象。所以在手动 <code>new</code> 实例化之前，vConsole 不会被插入到网页中。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>引入后, 需要手动初始化 vConsole：</p><br><div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vConsole <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">VConsole</span>(option);</pre></div><br><p><code>option</code> 是一个选填的 object 对象，具体配置定义请参阅 <a href="https://github.com/Tencent/vConsole/blob/dev/doc/public_properties_methods_CN.md" target="_blank" rel="noopener">公共属性及方法</a>。</p><br><p>使用 <code>setOption()</code> 来更新 <code>option</code>：</p><br><div class="highlight highlight-source-js"><pre><span class="pl-smi">vConsole</span>.<span class="pl-en">setOption</span>(<span class="pl-s"><span class="pl-pds">‘</span>maxLogNumber<span class="pl-pds">‘</span></span>, <span class="pl-c1">5000</span>);<br><span class="pl-c"><span class="pl-c">//</span> 或者：</span><br><span class="pl-smi">vConsole</span>.<span class="pl-en">setOption</span>({maxLogNumber<span class="pl-k">:</span> <span class="pl-c1">5000</span>});<br>###    打印日志<br>与 <span class="pl-c1">PC</span> 端打印 log 一致，可直接使用 <span class="pl-s"><span class="pl-pds"><code>&lt;/span&gt;console.log()&lt;span class=&quot;pl-pds&quot;&gt;</code></span></span> 等方法直接打印日志：<br><br><span class="pl-s"><span class="pl-pds"><code>&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;</code></span><span class="pl-pds">`</span>javascript</span><br><span class="pl-s">console.log(‘Hello World’);</span></pre></div><br><p>未加载 vConsole 模块时，<code>console.log()</code> 会直接打印到原生控制台中；加载 vConsole 后，日志会打印到页面前端+原生控制台。</p><h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h3><p></p><p>支持 5 种不同类型的日志，会以不同的颜色输出到前端面板：</p><p></p><div class="highlight highlight-source-js"><pre><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">‘</span>foo<span class="pl-pds">‘</span></span>);   <span class="pl-c"><span class="pl-c">//</span> 白底黑字</span><br><span class="pl-en">console</span>.<span class="pl-c1">info</span>(<span class="pl-s"><span class="pl-pds">‘</span>bar<span class="pl-pds">‘</span></span>);  <span class="pl-c"><span class="pl-c">//</span> 白底紫字</span><br><span class="pl-en">console</span>.<span class="pl-c1">debug</span>(<span class="pl-s"><span class="pl-pds">‘</span>oh<span class="pl-pds">‘</span></span>);  <span class="pl-c"><span class="pl-c">//</span> 白底黄字</span><br><span class="pl-en">console</span>.<span class="pl-c1">warn</span>(<span class="pl-s"><span class="pl-pds">‘</span>foo<span class="pl-pds">‘</span></span>);  <span class="pl-c"><span class="pl-c">//</span> 黄底黄字</span><br><span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">‘</span>bar<span class="pl-pds">‘</span></span>); <span class="pl-c"><span class="pl-c">//</span> 红底红字</span></pre></div><h3 id="Object-Array-结构化展示"><a href="#Object-Array-结构化展示" class="headerlink" title="Object/Array 结构化展示"></a>Object/Array 结构化展示</h3><p></p><p>支持打印 Object 或 Array 变量，会以结构化 JSON 形式输出（并折叠）：</p><p></p><div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {};<br><span class="pl-smi">obj</span>.<span class="pl-smi">foo</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">‘</span>bar<span class="pl-pds">‘</span></span>;<br><span class="pl-en">console</span>.<span class="pl-c1">log</span>(obj);<br><span class="pl-c"><span class="pl-c">/<em></em></span></span><br><span class="pl-c">Object</span><br><span class="pl-c">{</span><br><span class="pl-c">  foo: “bar”</span><br><span class="pl-c">}</span><br><span class="pl-c"><span class="pl-c">/</span></span></pre></div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p></p><p>支持传入多个参数，会以空格隔开：</p><p></p><div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> uid <span class="pl-k">=</span> <span class="pl-c1">233</span>;<br><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">‘</span>UserID:<span class="pl-pds">‘</span></span>, uid); <span class="pl-c"><span class="pl-c">//</span> 打印出 UserID: 233</span></pre></div><h3 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h3><p></p><p>支持使用 <code>[system]</code> 作为第一个参数，来将 log 输出到 System 面板：</p><p></p><div class="highlight highlight-source-js"><pre><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">‘</span>[system]<span class="pl-pds">‘</span></span>, <span class="pl-s"><span class="pl-pds">‘</span>foo<span class="pl-pds">‘</span></span>); <span class="pl-c"><span class="pl-c">//</span> ‘foo’ 会输出到 System 面板</span><br><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">‘</span>[system] bar<span class="pl-pds">‘</span></span>); <span class="pl-c"><span class="pl-c">//</span> 这行日志会输出到 Log 面板而非 System 面板</span></pre></div><h3 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h3><h4 id="Network-网络"><a href="#Network-网络" class="headerlink" title="Network 网络"></a>Network 网络</h4><p></p><p>所有 <code>XMLHttpRequest</code> 请求都会被显示到 Network tab 中。</p><p></p><p></p><p>若不希望一个请求显示在面板中，可添加属性 <code>_noVConsole = true</code> 到 XHR 对象中：</p><p></p><div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> xhr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">XMLHttpRequest</span>();<br><span class="pl-smi">xhr</span>.<span class="pl-smi">_noVConsole</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>; <span class="pl-c"><span class="pl-c">//</span> 不会显示到 tab 中</span><br><span class="pl-smi">xhr</span>.<span class="pl-c1">open</span>(<span class="pl-s"><span class="pl-pds">“</span>GET<span class="pl-pds">“</span></span>, <span class="pl-s"><span class="pl-pds">‘</span><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a><span class="pl-pds">‘</span></span>);<br><span class="pl-smi">xhr</span>.<span class="pl-c1">send</span>();</pre></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在开发手机版网页的时候，常常会出现下面的情景：&lt;br&gt;开发时，在自己电脑上运行得好好的，在手机上打开就挂了，但是手机上又看不到error log；&lt;br&gt;有时候上线后，某用户表示页面失灵，但我们自己又重现不出来，看不到用户侧的出错信息。&lt;br&gt;第一种情况还可以通过电脑连
      
    
    </summary>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>手机淘宝：移动端页面适配解决方案</title>
    <link href="http://datalearn.top/2018/04/21/H502/"/>
    <id>http://datalearn.top/2018/04/21/H502/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:32.276Z</updated>
    
    <content type="html"><![CDATA[<p>对于一枚前端而言，天天和页面打交道（H5页面），那么布局的活总是少不了，这也将面临不同终端的适配问题。页面布局总是或多或少会有一些蛋疼的事情发生。如果是的话，建议你花点时间阅读完下面扯蛋的东东。</p><h3 id="Flexible承载的使命"><a href="#Flexible承载的使命" class="headerlink" title="Flexible承载的使命"></a>Flexible承载的使命</h3><p>Flexible到今天也有几年的历史了，解救了很多同学针对于H5页面布局的适配问题。而这套方案也相对而言是一个较为成熟的方案。简单的回忆一下，当初为了能让页面更好的适配各种不同的终端，通过Hack手段来根据设备的dpr值相应改变<meta>标签中viewport的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- dpr = 1--&gt; </span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=scale,maximum-scale=scale,minimum-scale=scale,user-scalable=no&quot;&gt;</span><br><span class="line">&lt;!-- dpr = 2--&gt; </span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;&gt; </span><br><span class="line">&lt;!-- dpr = 3--&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.3333333333,maximum-scale=0.3333333333,minimum-scale=0.3333333333,user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure><p>从而让页面达么缩放的效果，也变相的实现页面的适配功能。而其主要的思想有三点：</p><ul><li>根据dpr的值来修改viewport实现1px的线</li><li>根据dpr的值来修改html的font-size，从而使用rem实现等比缩放</li><li>使用Hack手段用rem模拟vw特性<br>那么时代在变化，前端技术在不断的变化，试问：Flexible还是最佳方案？Flexible还有存在的必要吗？ 最近一直在探讨这方面，这里先告诉大家Flexible已经完成了他自身的历史使命，我们可以放下Flexible，拥抱新的变化。接下来的内容，我将分享一下我最近自己探讨的新的适配方案，或许很多团队同学已经开始使用了，如果有不对之处，希望能得到大婶们的指正；如果您有更好的方案，希望能一起分享一起探讨。</li></ul><h3 id="先上菜，再唠嗑"><a href="#先上菜，再唠嗑" class="headerlink" title="先上菜，再唠嗑"></a>先上菜，再唠嗑</h3><p>先上个二维码：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-1.png" alt=""><br>你可以使用手淘App、优酷APP、各终端自带的浏览器、UC浏览器、QQ浏览器、Safari浏览器和Chrome浏览器扫描上面的二维码，您看到相应的效果：<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-2.png" alt=""><br>部分手机效果<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-3.png" alt=""></p><h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>前面给大家介绍了这个方案目前得到的支持情况以及效果。也扯了不少废话，接下来进入正题吧。</p><p>在移动端布局，我们需要面对两个最为重要的问题：</p><ul><li>各终端下的适配问题</li><li>Retina屏的细节处理</li></ul><p>不同的终端，我们面对的屏幕分辨率、DPR、1px、2x图等一系列的问题。那么这个布局方案也是针对性的解决这些问题，只不过解决这些问题不再是使用Hack手段来处理，而是直接使用原生的CSS技术来处理的。</p><h3 id="适配终端"><a href="#适配终端" class="headerlink" title="适配终端"></a>适配终端</h3><p>首要解决的是适配终端。回想一下，以前的Flexible方案是通过JavaScript来模拟vw的特性，那么到今天为止，vw已经得到了众多浏览器的支持，也就是说，可以直接考虑将vw单位运用于我们的适配布局中。</p><p>众所周知，vw是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小。用下图简单的来示意一下：<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-4.png" alt=""></p><blockquote><p>因为Viewport涉及到的知识点很多，想了解的同学可以看淘宝前端负责人大漠老师写的<a href="https://www.w3cplus.com/css/viewports.html" target="_blank" rel="noopener">这篇文章</a>来加深认识。</p></blockquote><p>在CSS Values and Units Module Level 3中和Viewport相关的单位有四个，分别为vw、vh、vmin和vmax。</p><ul><li>vw：是Viewport’s width的简写,1vw等于window.innerWidth的1%</li><li>vh：和vw类似，是Viewport’s height的简写，1vh等于window.innerHeihgt的1%</li><li>vmin：vmin的值是当前vw和vh中较小的值</li><li>vmax：vmax的值是当前vw和vh中较大的值</li></ul><blockquote><p>vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。</p></blockquote><p>还是用一张图来示意吧，一图胜于千言万语：<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-5.png" alt=""><br>所以在这个方案中大胆的使用vw来替代以前Flexible中的rem缩放方案。先来回归到我们的实际业务中来。目前出视觉设计稿，我们都是使用750px宽度的，从上面的原理来看，那么100vw = 750px，即1vw = 7.5px。那么我们可以根据设计图上的px值直接转换成对应的vw值。看到这里，很多同学开始感到崩溃，又要计算，能不能简便一点，能不能再简单一点，其实是可以的，我们可以使用PostCSS的插件postcss-px-to-viewport，让我们可以直接在代码中写px，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[w-369]</span><br><span class="line">&#123; </span><br><span class="line">width: 369px; </span><br><span class="line">&#125; </span><br><span class="line">[w-369] h2 span &#123;</span><br><span class="line"> background: #FF5000; </span><br><span class="line"> color: #fff; </span><br><span class="line"> display: inline-block; </span><br><span class="line"> border-radius: 4px; </span><br><span class="line"> font-size: 20px; </span><br><span class="line"> text-shadow: 0 2px 2px #FF5000; </span><br><span class="line"> padding: 2px 5px; </span><br><span class="line"> margin-right: 5px; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>PostCSS编译之后就是我们所需要的带vw代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[w-369]</span><br><span class="line">&#123;</span><br><span class="line"> width: 49.2vw;</span><br><span class="line">&#125; </span><br><span class="line">[w-369]h2 span &#123; </span><br><span class="line">background: #ff5000;</span><br><span class="line">color: #fff; </span><br><span class="line">display: inline-block; </span><br><span class="line">border-radius: .53333vw; </span><br><span class="line">text-shadow: 0 0.26667vw 0.26667vw #ff5000; </span><br><span class="line">padding: .26667vw .66667vw; </span><br><span class="line">&#125; </span><br><span class="line">[w-369] h2 span, [w-369] i </span><br><span class="line">&#123; </span><br><span class="line">font-size: 2.66667vw; </span><br><span class="line">margin-right: .66667vw; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用的时候，你可以对该插件进行相关的参数配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;postcss-px-to-viewport&quot;: </span><br><span class="line">&#123; viewportWidth: 750, </span><br><span class="line">viewportHeight: 1334, </span><br><span class="line">unitPrecision: 5, </span><br><span class="line">viewportUnit: &apos;vw&apos;, </span><br><span class="line">selectorBlackList: [], </span><br><span class="line">minPixelValue: 1, </span><br><span class="line">mediaQuery: false </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你的设计稿不是750px而是1125px，那么你就可以修改vewportWidth的值<br>上面解决了px到vw的转换计算。那么在哪些地方可以使用vw来适配我们的页面。根据相关的测试：</p><ul><li>容器适配，可以使用vw</li><li>文本的适配，可以使用vw</li><li>大于1px的边框、圆角、阴影都可以使用vw</li><li>内距和外距，可以使用vw</li></ul><p>另外有一个细节需要特别的提出，比如我们有一个这样的设计：<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-6.png" alt=""><br>如果我们直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[w-188-246] &#123; </span><br><span class="line">width: 188px; </span><br><span class="line">&#125; </span><br><span class="line">[w-187-246]&#123; </span><br><span class="line">width: 187px </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果会造成[w-187-246]容器的高度小于[w-188-246]容器的高度。这个时候我们就需要考虑到容器的长宽比缩放。这方面的方案很多，但我还是推荐工具化来处理，这里推荐@一丝 大神写的一个<a href="https://github.com/yisibl/postcss-aspect-ratio-mini" target="_blank" rel="noopener">PostCSS</a>插件postcss-aspect-ratio-mini。这个插件使用很简单，不需要做任何的配置，你只需要本地安装一下就OK。使用的时候如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[aspectratio] </span><br><span class="line">&#123; </span><br><span class="line">position: relative; </span><br><span class="line">&#125; [aspectratio]::before &#123; </span><br><span class="line">content: &apos;&apos;; </span><br><span class="line">display: block; </span><br><span class="line">width: 1px; </span><br><span class="line">margin-left: -1px; </span><br><span class="line">height: 0; </span><br><span class="line">&#125; </span><br><span class="line">[aspectratio-content] &#123; </span><br><span class="line">position: absolute; </span><br><span class="line">top: 0; </span><br><span class="line">left: 0; </span><br><span class="line">right: 0; </span><br><span class="line">bottom: 0; </span><br><span class="line">width: 100%; </span><br><span class="line">height: 100%; </span><br><span class="line">&#125; </span><br><span class="line">[aspectratio][aspect-ratio=&quot;188/246&quot;]&#123; </span><br><span class="line">aspect-ratio: &apos;188:246&apos;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[aspectratio][aspect-ratio=&quot;188/246&quot;]:before</span><br><span class="line">&#123; </span><br><span class="line">padding-top: 130.85106382978725%; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以完美的实现长宽比的效果。</p><blockquote><p>目前采用PostCSS插件只是一个过渡阶段，在将来我们可以直接在CSS中使用aspect-ratio属性来实现长宽比。</p></blockquote><h3 id="解决1px方案"><a href="#解决1px方案" class="headerlink" title="解决1px方案"></a>解决1px方案</h3><p>前面提到过，对于1px是不建议将其转换成对应的vw单位的，但在Retina下，我们始终是需要面对如何解决1px的问题。<br>在这里的话，个人推荐一种解决1px的方案：使用PostCSS插件，解决1px可以使用postcss-write-svg。</p><p>使用postcss-write-svg你可以通过border-image或者background-image两种方式来处理。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@svg 1px-border </span><br><span class="line">&#123; </span><br><span class="line">height: 2px; </span><br><span class="line">    @rect </span><br><span class="line">    &#123; </span><br><span class="line">    fill: var(--color, black); </span><br><span class="line">    width: 100%; </span><br><span class="line">    height: 50%; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">.example &#123; </span><br><span class="line">border: 1px solid transparent; </span><br><span class="line">border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样PostCSS会自动帮你把CSS编译出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.example &#123; </span><br><span class="line">border: 1px solid transparent; </span><br><span class="line">border-image: url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; height=&apos;2px&apos;%3E%3Crect fill=&apos;%2300b1ff&apos; width=&apos;100%25&apos; height=&apos;50%25&apos;/%3E%3C/svg%3E&quot;) 2 2 stretch; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostCSS的插件是不是比我们修改图片要来得简单与方便。</p><p>上面演示的是使用border-image方式，除此之外还可以使用background-image来实现。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@svg square &#123; </span><br><span class="line">    @rect &#123; </span><br><span class="line">    fill: var(--color, black); </span><br><span class="line">    width: 100%; height: 100%; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">#example </span><br><span class="line">&#123; </span><br><span class="line">background: white svg(square param(--color #00b1ff)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出来就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#example </span><br><span class="line">&#123; </span><br><span class="line">background: white url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos;%3E%3Crect fill=&apos;%2300b1ff&apos; width=&apos;100%25&apos; height=&apos;100%25&apos;/%3E%3C/svg%3E&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案简单易用，是我所需要的。目前测试下来，基本能达到我所需要的需求。但有一点千万别忘了，记得在<head>中添加：</head></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><p>上面阐述的是这个适配方案中所用到的技术点，简单的总结一下：</p><ul><li>使用vw来实现页面的适配，并且通过PostCSS的插件postcss-px-to-viewport把px转换成vw。这样的好处是，我们在撸码的时候，不需要进行任何的计算，你只需要根据设计图写px单位</li><li>为了更好的实现长宽比，特别是针对于img、vedio和iframe元素，通过PostCSS插件postcss-aspect-ratio-mini来实现，在实际使用中，只需要把对应的宽和高写进去即可</li><li><p>为了解决1px的问题，使用PostCSS插件postcss-write-svg,自动生成border-image或者background-image的图片</p><h3 id="降级处理"><a href="#降级处理" class="headerlink" title="降级处理"></a>降级处理</h3><p>最开始提到过，到目前为止，还有很多机型是不支持vw的适配方案。那么如果业务需要，应该怎么处理呢？有两种方式可以进行降级处理：</p></li><li><p>CSS Houdini：通过CSS Houdini针对vw做处理，调用CSS Typed OM Level1 提供的CSSUnitValue API。</p></li><li>CSS Polyfill：通过相应的Polyfill做相应的处理，目前针对于vw单位的Polyfill主要有：vminpoly、Viewport Units Buggyfill、vunits.js和Modernizr。个人推荐采用Viewport Units Buggyfill<h3 id="Viewport不足之处"><a href="#Viewport不足之处" class="headerlink" title="Viewport不足之处"></a>Viewport不足之处</h3>采用vw来做适配处理并不是只有好处没有任何缺点。有一些细节之处还是存在一定的缺陷的。比如当容器使用vw单位，margin采用px单位时，很容易造成整体宽度超过100vw，从而影响布局效果。对于类似这样的现象，我们可以采用相关的技术进行规避。比如将margin换成padding，并且配合box-sizing。只不过这不是最佳方案，随着将来浏览器或者应用自身的Webview对calc()函数的支持之后，碰到vw和px混合使用的时候，可以结合calc()函数一起使用，这样就可以完美的解决。</li></ul><p>另外一点，px转换成vw单位，多少还会存在一定的像素差，毕竟很多时候无法完全整除。</p><p>到目前为止，我发现的两个不足之处。或许在后面的使用当中，还会碰到一些其他不为人之的坑。事实也是如此，不管任何方案，踩得坑越多，该方案也越来越强大。希望喜欢这个适配方案的同学和我一起踩坑，让其更为完善。</p><h3 id="判断自己的应用是否支持"><a href="#判断自己的应用是否支持" class="headerlink" title="判断自己的应用是否支持"></a>判断自己的应用是否支持</h3><p>然该文的示例，进行了多方面的测试。但很多同学还是会担忧自己的APP应用是否支持该方案，而不敢大胆尝试或者使用。其实不必要这么担心，你可以拿自己的设备，或者应用扫描下面的二维码：<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-7.png" alt=""><br>当页面跑完测试之后，找到对应的Values and Units列表项：<br><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-8.png" alt=""><br>如果vw栏是绿色代表你的设备或应用支持该方案；反之则不支持。另外你也可以经常关注<a href="https://github.com/airen/css3test" target="_blank" rel="noopener">css3test</a>相关的更新，后面将会根据相关的规范更新测试代码，让你能快速掌握哪些属性可以大胆使用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>H5页面的适配方案总是令人蛋疼的，事实上页面的布局总是令人蛋疼的。但技术是不断革新的，我们可以随着保持对新技术的关注，尝试这些新特性运用到实际项目中，只有这样，我们解决问题的方案才会越来越完善。</p><p>到写这篇文章为止，虽然还有那么一两款机型不支持vw，但并不影响我们去使用。只有不断去尝试，才会有进步。在此，希望大家大胆尝试，一起让该方案变得更完美。如果你有更好的建议，或者你踩到任何坑，欢迎在下面的评论中与我分享，或者发邮件给我一起讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一枚前端而言，天天和页面打交道（H5页面），那么布局的活总是少不了，这也将面临不同终端的适配问题。页面布局总是或多或少会有一些蛋疼的事情发生。如果是的话，建议你花点时间阅读完下面扯蛋的东东。&lt;/p&gt;
&lt;h3 id=&quot;Flexible承载的使命&quot;&gt;&lt;a href=&quot;#Fl
      
    
    </summary>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>禁止Windows10自动更新</title>
    <link href="http://datalearn.top/2018/04/21/win10update/"/>
    <id>http://datalearn.top/2018/04/21/win10update/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:58.005Z</updated>
    
    <content type="html"><![CDATA[<p>windows10系统的自动更新的确令人很困恼，总是会在后台自动下载并重启，即使是关闭windows update服务也不能完全禁止，下面提供两种方法可以有效的禁止windows自动更新。</p><h3 id="使用DISM-优化功能"><a href="#使用DISM-优化功能" class="headerlink" title="使用DISM++优化功能"></a>使用DISM++优化功能</h3><p>Dism++是由初雨团队采用微软内部API编写的一款开源免费的实用工具，最开始的名字叫Windows更新清理工具，号称全球第一款基于CBS的Dism GUI实现！Dism++可以说是一个Dism的GUI版，但是并不依赖Dism，直接基于更底层的CBS（Component Based Servicing Reference）。这个我们主要使用到它的“系统优化”功能。</p><p>打开DISM++官网并点击Dism++ x86/x64下载最新版的DISM++。<br><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232701_206.png" alt=""><br><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232707_207.png" alt=""><br>解压下载的压缩包到你想要解压到的地方，例如G:\Program Files\Dism++\<br><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232711_494.png" alt=""><br>根据系统位数打开相应的程序，并打开“控制面板”&gt;“系统优化”&gt;“Windows Update”，打开“更新挂起时如果有用户登录不自动重启计算机（by Rambin）”，设置“将? Windows Update自动更新调整为”为“从不检查（不推荐）”，如下图，其他选项根据需要自行设置。<br><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232716_238.png" alt=""></p><h3 id="导入一个不存在的WSUS服务"><a href="#导入一个不存在的WSUS服务" class="headerlink" title="导入一个不存在的WSUS服务"></a>导入一个不存在的WSUS服务</h3><p>WSUS是Windows Server Update Services的简称，它在以前Windows Update Services的基础上有了很大的改善。目前的版本可以更新更多的Windows补丁，同时具有报告功能和导向性能，管理员还可以控制更新过程。通过注册表导入一个不存在的WSUS服务，可以杜绝Windows Update自动更新。</p><p>新建一个“文本文档”，编辑如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU]</span><br><span class="line"></span><br><span class="line">&quot;NoAutoUpdate&quot;=dword:00000000</span><br><span class="line"></span><br><span class="line">&quot;AUOptions&quot;=dword:00000002</span><br><span class="line"></span><br><span class="line">&quot;ScheduledInstallDay&quot;=dword:00000000</span><br><span class="line"></span><br><span class="line">&quot;UseWUServer&quot;=dword:00000001</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate]</span><br><span class="line"></span><br><span class="line">&quot;WUServer&quot;=&quot;http://wsus.ithome.com&quot;</span><br><span class="line"></span><br><span class="line">&quot;WUStatusServer&quot;=&quot;http://wsus.ithome.com&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate]</span><br><span class="line"></span><br><span class="line">&quot;SusClientId&quot;=-</span><br></pre></td></tr></table></figure><p><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232721_972.png" alt=""><br>为方便记忆，将其保存并命名为“wsus_enable.reg”，然后双击打开并确认导入注册表，然后重启电脑。<br><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232726_314.png" alt=""><br>重启之后，由于导入了一个不存在的WSUS服务，“检查更新”会一直报错而无法更新，如需更新只能手动点击“联机查找‘Microsoft更新’中的更新”，更新才能正常进行，这也达到了避免Windows Update自动更新和重启的目的。<br><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232730_753.png" alt=""><br>如需删除WSUS服务，仅需新建一个“文本文档”，编辑如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate]</span><br></pre></td></tr></table></figure></p><p><img src="http://img.ithome.com/newsuploadfiles/2018/4/20180420_232735_861.png" alt=""><br>为方便记忆，将其保存并命名为“wsus_disable.reg”，然后双击打开并确认导入注册表，然后重启电脑即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;windows10系统的自动更新的确令人很困恼，总是会在后台自动下载并重启，即使是关闭windows update服务也不能完全禁止，下面提供两种方法可以有效的禁止windows自动更新。&lt;/p&gt;
&lt;h3 id=&quot;使用DISM-优化功能&quot;&gt;&lt;a href=&quot;#使用DISM-
      
    
    </summary>
    
      <category term="实用教程" scheme="http://datalearn.top/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="软件" scheme="http://datalearn.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0配置mint-ui踩过的那些坑</title>
    <link href="http://datalearn.top/2018/03/09/mintui01/"/>
    <id>http://datalearn.top/2018/03/09/mintui01/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:18.238Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发项目的时候逐渐采用vue.js+mint-ui的技术栈，但是昨天开始配置开发环境的时候，遇到了各种报错，即使是按照两家的官方文档配置，也还是会报错，晚上下班后回去配置了一晚上，才终于把它配置好，所以就记录下来，以防后面再次踩坑。。</p><h3 id="vue-js介绍"><a href="#vue-js介绍" class="headerlink" title="vue.js介绍"></a>vue.js介绍</h3><p>Vue.js 是一个用于创建 web 交互界面的。其特点是</p><ol><li>简洁 HTML 模板 + JSON 数据，再创建一个 Vue 实例，就这么简单。</li><li>数据驱动 自动追踪依赖的模板表达式和计算属性。</li><li>组件化 用解耦、可复用的组件来构造界面。</li><li>轻量 ~24kb min+gzip，无依赖。</li><li>快速 精确有效的异步批量 DOM 更新。</li><li>模块友好 通过 NPM 或 Bower 安装，无缝融入你的工作流。</li></ol><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js中文官网</a></p><h3 id="mint-ui介绍"><a href="#mint-ui介绍" class="headerlink" title="mint-ui介绍"></a>mint-ui介绍</h3><p>Mint UI是饿了么前端团队开源的基于 Vue.js 的移动端组件库<br>特点是：</p><ol><li>Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。</li><li>真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件，无需再纠结文件体积过大。</li><li>考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。</li><li>依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。</li></ol><p><a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">Mint UI中文官网</a></p><h3 id="创建Vue-js项目"><a href="#创建Vue-js项目" class="headerlink" title="创建Vue.js项目"></a>创建Vue.js项目</h3><p>首先根据vue官网给出的方法在本地创建一个vue项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line"># 安装依赖，走你</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><h3 id="配置Mint-UI-环境"><a href="#配置Mint-UI-环境" class="headerlink" title="配置Mint UI 环境"></a>配置Mint UI 环境</h3><p>接着根据Mint UI的官网在项目中引入Mint UI的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mint-ui -S</span><br></pre></td></tr></table></figure><p>然后在项目中的main.js文件引入所有组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import MintUI from &apos;mint-ui&apos;</span><br><span class="line">import &apos;mint-ui/lib/style.css&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(MintUI)</span><br></pre></td></tr></table></figure><p>好了根据官网所说的，以上代码便完成了 Mint UI 的引入。</p><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>最后根据官网的内容在APP.vue里面写一个button组件看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;mt-button @click.native=&quot;handleClick&quot;&gt;按钮&lt;/mt-button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick: function() &#123;</span><br><span class="line">      this.$toast(&apos;Hello world!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>好了，环境搭建完成，我们来运行项目吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>然后就啪啪啪各种报错<br><img src="http://p3th9y4pk.bkt.clouddn.com/4.png" alt=""></p><h3 id="解决错误"><a href="#解决错误" class="headerlink" title="解决错误"></a>解决错误</h3><p>首先你需要在本地项目中安装CSS解释器</p><p><code>npm i css-loader style-loader -D</code></p><p>然后在build文件夹下面的webpack.base.conf.js文件里面配置如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        include: [</span><br><span class="line">          /src/,</span><br><span class="line">          &apos;/node_modules/mint-ui/lib/&apos;   </span><br><span class="line">        ],</span><br><span class="line">        use:[</span><br><span class="line">          &#123;loader:&quot;style-loader&quot;&#125;,</span><br><span class="line">          &#123;loader:&quot;css-loader&quot;&#125;,</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>如果你报es2015之类的错误，则需要将.babelrc文件修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;component&quot;, [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;libraryName&quot;: &quot;mint-ui&quot;,</span><br><span class="line">      &quot;style&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后运行"><a href="#最后运行" class="headerlink" title="最后运行"></a>最后运行</h3><p>环境配置好后，我们最后再运行一下。</p><p><code>npm run dev</code></p><p>终于可以了，就此，环境配置完成。<br><img src="http://p3th9y4pk.bkt.clouddn.com/5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近开发项目的时候逐渐采用vue.js+mint-ui的技术栈，但是昨天开始配置开发环境的时候，遇到了各种报错，即使是按照两家的官方文档配置，也还是会报错，晚上下班后回去配置了一晚上，才终于把它配置好，所以就记录下来，以防后面再次踩坑。。&lt;/p&gt;
&lt;h3 id=&quot;vue-j
      
    
    </summary>
    
      <category term="编程技术" scheme="http://datalearn.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>前端常见问题及答案汇总</title>
    <link href="http://datalearn.top/2018/03/07/FEinterview/"/>
    <id>http://datalearn.top/2018/03/07/FEinterview/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:28.591Z</updated>
    
    <content type="html"><![CDATA[<p>个人收集的前端知识点、问题和答案，参考答案仅代表个人观点，方便复习，目录如下，通过文档内搜索目录可快速定位章节。</p><h3 id="HTML，HTTP，web综合"><a href="#HTML，HTTP，web综合" class="headerlink" title="HTML，HTTP，web综合"></a>HTML，HTTP，web综合</h3><blockquote><p> 常见排序算法的时间复杂度,空间复杂度</p></blockquote><p><img src="http://p3th9y4pk.bkt.clouddn.com/sort-compare.png" alt="排序算法比较"></p><blockquote><p> 前端需要注意哪些SEO</p></blockquote><ol><li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li><li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用js输出：爬虫不会执行js获取内容</li><li>少用iframe：搜索引擎不会抓取iframe中的内容</li><li>非装饰性图片必须加alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ol><blockquote><p> web开发中会话跟踪的方法有哪些</p></blockquote><ol><li>cookie</li><li>session</li><li>url重写</li><li>隐藏input</li><li>ip地址</li></ol><blockquote><p> <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</p></blockquote><ol><li><code>title</code>是<a href="http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.core" target="_blank" rel="noopener">global attributes</a>之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。</li><li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ol><blockquote><p> doctype是什么,举例常见doctype及特点</p></blockquote><ol><li><code>&lt;!doctype&gt;</code>声明必须处于HTML文档的头部，在<code>&lt;html&gt;</code>标签之前，HTML5中不区分大小写</li><li><code>&lt;!doctype&gt;</code>声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</li><li>现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</li><li>在HTML4.01中<code>&lt;!doctype&gt;</code>声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</li><li>HTML5不基于SGML，所以不用指定DTD</li></ol><p>常见dotype：</p><ol><li><strong>HTML4.01 strict</strong>：不允许使用表现性、废弃元素（如font）以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li><li><strong>HTML4.01 Transitional</strong>:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></li><li><strong>HTML4.01 Frameset</strong>:允许表现性元素，废气元素以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></li><li><strong>XHTML1.0 Strict</strong>:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></li><li><strong>XHTML1.0 Transitional</strong>:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： <code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></li><li><strong>XHTML 1.0 Frameset</strong>:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></li><li><strong>HTML 5</strong>: <code>&lt;!doctype html&gt;</code></li></ol><blockquote><p> HTML全局属性(global attribute)有哪些</p></blockquote><p>参考资料：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes" target="_blank" rel="noopener">MDN: html global attribute</a>或者<a href="http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.core" target="_blank" rel="noopener">W3C HTML global-attributes</a></p><ul><li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href="#" accesskey="a">aaa</a>在windows下的firefox中按<code>alt + shift + a</code>可激活元素</li><li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li><li><code>contenteditable</code>: 指定元素内容是否可编辑</li><li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li><li><code>data-*</code>: 为元素增加自定义属性</li><li><code>dir</code>: 设置元素文本方向</li><li><code>draggable</code>: 设置元素是否可拖拽</li><li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li><li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li><li><code>id</code>: 元素id，文档内唯一</li><li><code>lang</code>: 元素内容的的语言</li><li><code>spellcheck</code>: 是否启动拼写和语法检查</li><li><code>style</code>: 行内css样式</li><li><code>tabindex</code>: 设置元素可以获得焦点，通过tab可以导航</li><li><code>title</code>: 元素相关的建议信息</li><li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li></ul><blockquote><p> 什么是web语义化,有什么好处</p></blockquote><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。<br>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构<br>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如<a href="http://en.wikipedia.org/wiki/Microformats" target="_blank" rel="noopener">Microformat</a>通过添加符合规则的class描述信息<br>为什么需要语义化：</p><ul><li>去掉样式后页面呈现清晰的结构</li><li>盲人使用读屏器更好地阅读</li><li>搜索引擎更好地理解页面，有利于收录</li><li>便团队项目的可持续运作及维护</li></ul><blockquote><p> HTTP method</p></blockquote><ol><li>一台服务器要与HTTP1.1兼容，只要为资源实现<strong>GET</strong>和<strong>HEAD</strong>方法即可</li><li><strong>GET</strong>是最常用的方法，通常用于<strong>请求服务器发送某个资源</strong>。</li><li><strong>HEAD</strong>与GET类似，但<strong>服务器在响应中值返回首部，不返回实体的主体部分</strong></li><li><strong>PUT</strong>让服务器<strong>用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它</strong></li><li><strong>POST</strong>起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li><li><strong>TRACE</strong>会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li><li><strong>OPTIONS</strong>方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li><li><strong>DELETE</strong>请求服务器删除请求URL指定的资源</li></ol><blockquote><p> 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</p></blockquote><ol><li>在浏览器地址栏输入URL</li><li>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤<ol><li>如果资源未缓存，发起新请求</li><li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li><li>检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：<ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</li><li>浏览器<strong>组装一个HTTP（GET）请求报文</strong></li><li>浏览器<strong>获取主机ip地址</strong>，过程如下：<ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><strong>打开一个socket与目标IP地址，端口建立TCP链接</strong>，三次握手如下：<ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li>TCP链接建立后<strong>发送HTTP请求</strong></li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li><li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li><li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li><li>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong>：<ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li><li>如果资源可缓存，<strong>进行缓存</strong></li><li>对响应进行<strong>解码</strong>（例如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li><li><strong>构建DOM树</strong>：<ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li><li>构建<strong>CSSOM树</strong>：<ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><strong><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">根据DOM树和CSSOM树构建渲染树</a></strong>:<ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><strong>js解析如下</strong>：<ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete,window触发load事件</li></ol></li><li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li></ol><blockquote><p> HTTP request报文结构是怎样的<br><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="noopener">rfc2616</a>中进行了定义：</p></blockquote><ol><li>首行是<strong>Request-Line</strong>包括：<strong>请求方法</strong>，<strong>请求URI</strong>，<strong>协议版本</strong>，<strong>CRLF</strong></li><li>首行之后是若干行<strong>请求头</strong>，包括<strong>general-header</strong>，<strong>request-header</strong>或者<strong>entity-header</strong>，每个一行以CRLF结束</li><li>请求头和消息实体之间有一个<strong>CRLF分隔</strong></li><li>根据实际请求需要可能包含一个<strong>消息实体</strong><br>一个请求报文例子如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</span><br><span class="line">Host: www.w3.org</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</span><br><span class="line">Referer: https://www.google.com.hk/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">Cookie: authorstyle=yes</span><br><span class="line">If-None-Match: &quot;2cc8-3e3073913b100&quot;</span><br><span class="line">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class="line"></span><br><span class="line">name=qiu&amp;age=25</span><br></pre></td></tr></table></figure><blockquote><p> HTTP response报文结构是怎样的</p></blockquote><p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html" target="_blank" rel="noopener">rfc2616</a>中进行了定义：</p><ol><li>首行是状态行包括：<strong>HTTP版本，状态码，状态描述</strong>，后面跟一个CRLF</li><li>首行之后是<strong>若干行响应头</strong>，包括：<strong>通用头部，响应头部，实体头部</strong></li><li>响应头部和响应实体之间用<strong>一个CRLF空行</strong>分隔</li><li>最后是一个可能的<strong>消息实体</strong><br>响应报文例子如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 08 Jul 2014 05:28:43 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class="line">ETag: &quot;40d7-3e3073913b100&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 16599</span><br><span class="line">Cache-Control: max-age=21600</span><br><span class="line">Expires: Tue, 08 Jul 2014 11:28:43 GMT</span><br><span class="line">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</span><br><span class="line">Content-Type: text/html; charset=iso-8859-1</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 如何进行网站性能优化</p></blockquote><p><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">雅虎Best Practices for Speeding Up Your Web Site</a>：</p><ul><li><p>content方面</p><ol><li>减少HTTP请求：合并文件、CSS精灵、inline Image</li><li>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询</li><li>避免重定向：多余的中间访问</li><li>使Ajax可缓存</li><li>非必须组件延迟加载</li><li>未来所需组件预加载</li><li>减少DOM元素数量</li><li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li><li>减少iframe数量</li><li>不要404</li></ol></li><li><p>Server方面</p><ol><li>使用CDN</li><li>添加Expires或者Cache-Control响应头</li><li>对组件使用Gzip压缩</li><li>配置ETag</li><li>Flush Buffer Early</li><li>Ajax使用GET进行请求</li><li>避免空src的img标签</li></ol></li><li>Cookie方面<ol><li>减小cookie大小</li><li>引入资源的域名不要包含cookie</li></ol></li><li>css方面<ol><li>将样式表放到页面顶部</li><li>不使用CSS表达式</li><li>使用<link>不使用@import</li><li>不使用IE的Filter</li></ol></li><li>Javascript方面<ol><li>将脚本放到页面底部</li><li>将javascript和css从外部引入</li><li>压缩javascript和css</li><li>删除不需要的脚本</li><li>减少DOM访问</li><li>合理设计事件监听器</li></ol></li><li>图片方面<ol><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化css精灵</li><li>不要在HTML中拉伸图片</li><li>保证favicon.ico小并且可缓存</li></ol></li><li>移动方面<ol><li>保证组件小于25k</li><li>Pack Components into a Multipart Document</li></ol></li></ul><blockquote><p> 什么是渐进增强</p></blockquote><p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:</p><ul><li>所有浏览器都必须能访问基本内容</li><li>所有浏览器都必须能使用基本功能</li><li>所有内容都包含在语义化标签中</li><li>通过外部CSS提供增强的布局</li><li>通过非侵入式、外部javascript提供增强功能</li><li>end-user web browser preferences are respected</li></ul><blockquote><p> HTTP状态码及其含义</p></blockquote><p>参考<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">RFC 2616</a></p><ul><li>1XX：信息状态码<ul><li><strong>100 Continue</strong>：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求万仇向客户端发送一个最终响应</li><li><strong>101 Switching Protocols</strong>：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。</li></ul></li><li>2XX：成功状态码<ul><li><strong>200 OK</strong>：请求成功，请求所希望的响应头或数据体将随此响应返回</li><li><strong>201 Created</strong>：</li><li><strong>202 Accepted</strong>：</li><li><strong>203 Non-Authoritative Information</strong>：</li><li><strong>204 No Content</strong>：</li><li><strong>205 Reset Content</strong>：</li><li><strong>206 Partial Content</strong>：</li></ul></li><li>3XX：重定向<ul><li><strong>300 Multiple Choices</strong>：</li><li><strong>301 Moved Permanently</strong>：</li><li><strong>302 Found</strong>：</li><li><strong>303 See Other</strong>：</li><li><strong>304 Not Modified</strong>：</li><li><strong>305 Use Proxy</strong>：</li><li><strong>306 （unused）</strong>：</li><li><strong>307 Temporary Redirect</strong>：</li></ul></li><li>4XX：客户端错误<ul><li><strong>400 Bad Request</strong>:</li><li><strong>401 Unauthorized</strong>:</li><li><strong>402 Payment Required</strong>:</li><li><strong>403 Forbidden</strong>:</li><li><strong>404 Not Found</strong>:</li><li><strong>405 Method Not Allowed</strong>:</li><li><strong>406 Not Acceptable</strong>:</li><li><strong>407 Proxy Authentication Required</strong>:</li><li><strong>408 Request Timeout</strong>:</li><li><strong>409 Conflict</strong>:</li><li><strong>410 Gone</strong>:</li><li><strong>411 Length Required</strong>:</li><li><strong>412 Precondition Failed</strong>:</li><li><strong>413 Request Entity Too Large</strong>:</li><li><strong>414 Request-URI Too Long</strong>:</li><li><strong>415 Unsupported Media Type</strong>:</li><li><strong>416 Requested Range Not Satisfiable</strong>:</li><li><strong>417 Expectation Failed</strong>:</li></ul></li><li>5XX: 服务器错误<ul><li><strong>500 Internal Server Error</strong>:</li><li><strong>501 Not Implemented</strong>:</li><li><strong>502 Bad Gateway</strong>:</li><li><strong>503 Service Unavailable</strong>:</li><li><strong>504 Gateway Timeout</strong>:</li><li><strong>505 HTTP Version Not Supported</strong>:</li></ul></li></ul><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><blockquote><p> CSS选择器有哪些</p></blockquote><ol><li><strong>*通用选择器</strong>：选择所有元素，<strong>不参与计算优先级</strong>，兼容性IE6+</li><li><strong>#X id选择器</strong>：选择id值为X的元素，兼容性：IE6+</li><li><strong>.X 类选择器</strong>： 选择class包含X的元素，兼容性：IE6+</li><li><strong>X Y后代选择器</strong>： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+</li><li><strong>X 元素选择器</strong>： 选择标所有签为X的元素，兼容性：IE6+</li><li><strong>:link，：visited，：focus，：hover，：active链接状态</strong>： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+</li><li><strong>X + Y直接兄弟选择器</strong>：在<strong>X之后第一个兄弟节点</strong>中选择满足Y选择器的元素，兼容性： IE7+</li><li><strong>X &gt; Y子选择器</strong>： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+</li><li><strong>X ~ Y兄弟</strong>： 选择<strong>X之后所有兄弟节点</strong>中满足Y选择器的元素，兼容性： IE7+</li><li><strong>[attr]</strong>：选择所有设置了attr属性的元素，兼容性IE7+</li><li><strong>[attr=value]</strong>：选择属性值刚好为value的元素</li><li><strong>[attr~=value]</strong>：选择属性值为空白符分隔，其中一个的值刚好是value的元素</li><li><strong>[attr|=value]</strong>：选择属性值刚好为value或者value-开头的元素</li><li><strong>[attr^=value]</strong>：选择属性值以value开头的元素</li><li><strong>[attr$=value]</strong>：选择属性值以value结尾的元素</li><li><strong>[attr*=value]</strong>：选择属性值中包含value的元素</li><li><strong>[:checked]</strong>：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+</li><li><strong>X:after, X::after</strong>：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+</li><li><strong>:hover</strong>：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+</li><li><strong>:not(selector)</strong>：选择不符合selector的元素。<strong>不参与计算优先级</strong>，兼容性：IE9+</li><li><strong>::first-letter</strong>：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+</li><li><strong>::first-line</strong>：伪元素，选择块元素的第一行，兼容性IE5.5+</li><li><strong>:nth-child(an + b)</strong>：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n<br>&gt;= 0， 兼容性IE9+</li><li><strong>:nth-last-child(an + b)</strong>：伪类，选择后面有an + b - 1个兄弟节点的元素<br>其中n &gt;= 0，兼容性IE9+</li><li><strong>X:nth-of-type(an+b)</strong>：伪类，X为选择器，<strong>解析得到元素标签</strong>，选择<strong>前面</strong>有an + b - 1个<strong>相同标签</strong>兄弟节点的元素。兼容性IE9+</li><li><strong>X:nth-last-of-type(an+b)</strong>：伪类，X为选择器，解析得到元素标签，选择<strong>后面</strong>有an+b-1个相同<strong>标签</strong>兄弟节点的元素。兼容性IE9+</li><li><strong>X:first-child</strong>：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+</li><li><strong>X:last-child</strong>：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+</li><li><strong>X:only-child</strong>：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+</li><li><strong>X:only-of-type</strong>：伪类，选择X选择的元素，<strong>解析得到元素标签</strong>，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+</li><li><strong>X:first-of-type</strong>：伪类，选择X选择的元素，<strong>解析得到元素标签</strong>，如果该元素<br>是此此类型元素的第一个兄弟。选中它。兼容性IE9+</li></ol><blockquote><p> css sprite是什么,有什么优缺点</p></blockquote><p>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。</p><p>优点：</p><ol><li>减少HTTP请求数，极大地提高页面加载速度</li><li>增加图片信息重复度，提高压缩比，减少图片大小</li><li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li></ol><p>缺点：</p><ol><li>图片合并麻烦</li><li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li></ol><blockquote><p> <code>display: none;</code>与<code>visibility: hidden;</code>的区别<br>联系：它们都能让元素不可见</p></blockquote><p>区别：</p><ol><li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式</li><li>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</li><li>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容</li></ol><blockquote><p> css hack原理及常用hack</p></blockquote><p>原理：利用<strong>不同浏览器对CSS的支持和解析结果不一样</strong>编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释</p><ul><li>IE条件注释：适用于[IE5, IE9]常见格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE 6]&gt;</span><br><span class="line">Special instructions for IE 6 here</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><ul><li>选择器hack：不同浏览器对选择器的支持不一样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/***** Selector Hacks ******/</span><br><span class="line"></span><br><span class="line">/* IE6 and below */</span><br><span class="line">* html #uno  &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* IE7 */</span><br><span class="line">*:first-child+html #dos &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* IE7, FF, Saf, Opera  */</span><br><span class="line">html&gt;body #tres &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* IE8, FF, Saf, Opera (Everything but IE 6,7) */</span><br><span class="line">html&gt;/**/body #cuatro &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* Opera 9.27 and below, safari 2 */</span><br><span class="line">html:first-child #cinco &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* Safari 2-3 */</span><br><span class="line">html[xmlns*=&quot;&quot;] body:last-child #seis &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span><br><span class="line">body:nth-of-type(1) #siete &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span><br><span class="line">body:first-of-type #ocho &#123;  color: red &#125;</span><br><span class="line"></span><br><span class="line">/* saf3+, chrome1+ */</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio:0) &#123;</span><br><span class="line"> #diez  &#123; color: red  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* iPhone / mobile webkit */</span><br><span class="line">@media screen and (max-device-width: 480px) &#123;</span><br><span class="line"> #veintiseis &#123; color: red  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Safari 2 - 3.1 */</span><br><span class="line">html[xmlns*=&quot;&quot;]:root #trece  &#123; color: red  &#125;</span><br><span class="line"></span><br><span class="line">/* Safari 2 - 3.1, Opera 9.25 */</span><br><span class="line">*|html[xmlns*=&quot;&quot;] #catorce &#123; color: red  &#125;</span><br><span class="line"></span><br><span class="line">/* Everything but IE6-8 */</span><br><span class="line">:root *&gt; #quince &#123; color: red  &#125;</span><br><span class="line"></span><br><span class="line">/* IE7 */</span><br><span class="line">*+html #dieciocho &#123;  color: red &#125;</span><br><span class="line"></span><br><span class="line">/* Firefox only. 1+ */</span><br><span class="line">#veinticuatro,  x:-moz-any-link  &#123; color: red &#125;</span><br><span class="line"></span><br><span class="line">/* Firefox 3.0+ */</span><br><span class="line">#veinticinco,  x:-moz-any-link, x:default  &#123; color: red  &#125;</span><br></pre></td></tr></table></figure><ul><li>属性hack：不同浏览器解析bug或方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* IE6 */</span><br><span class="line">#once &#123; _color: blue &#125;</span><br><span class="line"></span><br><span class="line">/* IE6, IE7 */</span><br><span class="line">#doce &#123; *color: blue; /* or #color: blue */ &#125;</span><br><span class="line"></span><br><span class="line">/* Everything but IE6 */</span><br><span class="line">#diecisiete &#123; color/**/: blue &#125;</span><br><span class="line"></span><br><span class="line">/* IE6, IE7, IE8 */</span><br><span class="line">#diecinueve &#123; color: blue\9; &#125;</span><br><span class="line"></span><br><span class="line">/* IE7, IE8 */</span><br><span class="line">#veinte &#123; color/*\**/: blue\9; &#125;</span><br><span class="line"></span><br><span class="line">/* IE6, IE7 -- acts as an !important */</span><br><span class="line">#veintesiete &#123; color: blue !ie; &#125; /* string after ! can be anything */</span><br></pre></td></tr></table></figure><blockquote><p> specified value,computed value,used value计算方法</p></blockquote><ul><li><p>specified value: 计算方法如下：</p><ol><li>如果样式表设置了一个值，使用这个值</li><li>如果没有设置值，这个属性是继承属性，从父元素继承</li><li>如果没设置，并且不是继承属性，使用css规范指定的初始值</li></ol></li><li><p>computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。<strong>computed value的主要作用是用于继承</strong></p></li><li><p>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局，</p><ul><li>background-position</li><li>bottom, left, right, top</li><li>height, width</li><li>margin-bottom, margin-left, margin-right, margin-top</li><li>min-height, min-width</li><li>padding-bottom, padding-left, padding-right, padding-top</li><li>text-indent</li></ul></li></ul><blockquote><p> <code>link</code>与<code>@import</code>的区别</p></blockquote><ol><li><code>link</code>是HTML方式， <code>@import</code>是CSS方式</li><li><code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<a href="http://www.bluerobot.com/web/css/fouc.asp/" target="_blank" rel="noopener">FOUC</a></li><li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li><li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li><li><code>@import</code>必须在样式规则之前，可以在css文件中引用其他文件</li><li>总体来说：<strong><a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="noopener">link优于@import</a></strong></li></ol><blockquote><p> <code>display: block;</code>和<code>display: inline;</code>的区别</p></blockquote><p><code>block</code>元素特点：</p><p>1.处于常规流中时，如果<code>width</code>没有设置，会自动填充满父容器<br>2.可以应用<code>margin/padding</code><br>3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素<br>4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）<br>5.忽略<code>vertical-align</code></p><p><code>inline</code>元素特点</p><p>1.水平方向上根据<code>direction</code>依次布局<br>2.不会在元素前后进行换行<br>3.受<code>white-space</code>控制<br>4.<code>margin/padding</code>在竖直方向上无效，水平方向上有效<br>5.<code>width/height</code>属性对非替换行内元素无效，宽度由元素内容决定<br>6.非替换行内元素的行框高由<code>line-height</code>确定，替换行内元素的行框高由<code>height</code>,<code>margin</code>,<code>padding</code>,<code>border</code>决定<br>6.浮动或绝对定位时会转换为<code>block</code><br>7.<code>vertical-align</code>属性生效</p><blockquote><p> PNG,GIF,JPG的区别及如何选<br>参考资料： <a href="http://www.yuiblog.com/blog/2008/11/04/imageopt-2/" target="_blank" rel="noopener">选择正确的图片格式</a><br><strong>GIF</strong>:</p></blockquote><ol><li>8位像素，256色</li><li>无损压缩</li><li>支持简单动画</li><li>支持boolean透明</li><li>适合简单动画</li></ol><p><strong>JPEG</strong>：</p><ol><li>颜色限于256</li><li>有损压缩</li><li>可控制压缩质量</li><li>不支持透明</li><li>适合照片</li></ol><p><strong>PNG</strong>：</p><ol><li>有PNG8和truecolor PNG</li><li>PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画</li><li>适合图标、背景、按钮</li></ol><blockquote><p> CSS有哪些继承属性</p></blockquote><ul><li>关于文字排版的属性如：<ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font" target="_blank" rel="noopener">font</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/word-break" target="_blank" rel="noopener">word-break</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing" target="_blank" rel="noopener">letter-spacing</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-align" target="_blank" rel="noopener">text-align</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-rendering" target="_blank" rel="noopener">text-rendering</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/word-spacing" target="_blank" rel="noopener">word-spacing</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space" target="_blank" rel="noopener">white-space</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-indent" target="_blank" rel="noopener">text-indent</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform" target="_blank" rel="noopener">text-transform</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow" target="_blank" rel="noopener">text-shadow</a></li></ul></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/line-height" target="_blank" rel="noopener">line-height</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color" target="_blank" rel="noopener">color</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/visibility" target="_blank" rel="noopener">visibility</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor" target="_blank" rel="noopener">cursor</a></li></ul><blockquote><p> IE6浏览器有哪些常见的bug,缺陷或者与标准不一致的地方,如何解决</p></blockquote><ul><li>IE6不支持min-height，解决办法使用css hack：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.target &#123;</span><br><span class="line">    min-height: 100px;</span><br><span class="line">    height: auto !important;</span><br><span class="line">    height: 100px;   // IE6下内容高度超过会自动扩展高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>ol</code>内<code>li</code>的序号全为1，不递增。解决方法：为li设置样式<code>display: list-item;</code></p></li><li><p>未定位父元素<code>overflow: auto;</code>，包含<code>position: relative;</code>子元素，子元素高于父元素时会溢出。解决办法：1）子元素去掉<code>position: relative;</code>; 2）不能为子元素去掉定位时，父元素<code>position: relative;</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.outer &#123;</span><br><span class="line">    width: 215px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    overflow: auto;</span><br><span class="line">    position: relative;  /* 修复bug */</span><br><span class="line">&#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: purple;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>IE6只支持<code>a</code>标签的<code>:hover</code>伪类，解决方法：使用js为元素监听mouseenter，mouseleave事件，添加类实现效果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.p:hover,</span><br><span class="line">.hover &#123;</span><br><span class="line">    background: purple;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;p&quot; id=&quot;target&quot;&gt;aaaa bbbbb&lt;span&gt;DDDDDDDDDDDd&lt;/span&gt; aaaa lkjlkjdf j&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function addClass(elem, cls) &#123;</span><br><span class="line">    if (elem.className) &#123;</span><br><span class="line">        elem.className += &apos; &apos; + cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        elem.className = cls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function removeClass(elem, cls) &#123;</span><br><span class="line">    var className = &apos; &apos; + elem.className + &apos; &apos;;</span><br><span class="line">    var reg = new RegExp(&apos; +&apos; + cls + &apos; +&apos;, &apos;g&apos;);</span><br><span class="line">    elem.className = className.replace(reg, &apos; &apos;).replace(/^ +| +$/, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target = document.getElementById(&apos;target&apos;);</span><br><span class="line">if (target.attachEvent) &#123;</span><br><span class="line">    target.attachEvent(&apos;onmouseenter&apos;, function () &#123;</span><br><span class="line">        addClass(target, &apos;hover&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    target.attachEvent(&apos;onmouseleave&apos;, function () &#123;</span><br><span class="line">        removeClass(target, &apos;hover&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>IE5-8不支持<code>opacity</code>，解决办法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.opacity &#123;</span><br><span class="line">    opacity: 0.4</span><br><span class="line">    filter: alpha(opacity=60); /* for IE5-7 */</span><br><span class="line">    -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE 8*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>IE6在设置<code>height</code>小于<code>font-size</code>时高度值为<code>font-size</code>，解决办法：<code>font-size: 0;</code></li><li>IE6不支持PNG透明背景，解决办法: <strong>IE6下使用gif图片</strong></li><li>IE6-7不支持<code>display: inline-block</code>解决办法：设置inline并触发hasLayout</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: inline-block;</span><br><span class="line">*display: inline;</span><br><span class="line">*zoom: 1;</span><br></pre></td></tr></table></figure><ul><li>IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决办法：<br>1）使用padding控制间距。<br>2）浮动元素<code>display: inline;</code>这样解决问题且无任何副作用：css标准规定浮动元素display:inline会自动调整为block</li><li>通过为块级元素设置宽度和左右margin为auto时，IE6不能实现水平居中，解决方法：为父元素设置<code>text-align: center;</code></li></ul><blockquote><p> 容器包含若干浮动元素时如何清理(包含)浮动</p></blockquote><ol><li>容器元素闭合标签前添加额外元素并设置<code>clear: both</code></li><li>父元素触发块级格式化上下文(见块级可视化上下文部分)</li><li>设置容器元素伪元素进行清理<a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">推荐的清理浮动方法</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在标准浏览器下使用</span><br><span class="line">* 1 content内容为空格用于修复opera下文档中出现</span><br><span class="line">*   contenteditable属性时在清理浮动元素上下的空白</span><br><span class="line">* 2 使用display使用table而不是block：可以防止容器和</span><br><span class="line">*   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7</span><br><span class="line">*   zoom: 1;一致</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &quot; &quot;; /* 1 */</span><br><span class="line">    display: table; /* 2 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* IE 6/7下使用</span><br><span class="line">* 通过触发hasLayout实现包含浮动</span><br><span class="line">**/</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 什么是FOUC?如何避免<br>Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。<strong>解决方法</strong>：把样式表放到文档的<code>head</code></p></blockquote><blockquote><p> 如何创建块级格式化上下文(block formatting context),BFC有什么用<br>创建规则：</p></blockquote><ol><li>根元素</li><li>浮动元素（<code>float</code>不是<code>none</code>）</li><li>绝对定位元素（<code>position</code>取值为<code>absolute</code>或<code>fixed</code>）</li><li><code>display</code>取值为<code>inline-block</code>,<code>table-cell</code>, <code>table-caption</code>,<code>flex</code>, <code>inline-flex</code>之一的元素</li><li><code>overflow</code>不是<code>visible</code>的元素</li></ol><p>作用：</p><ol><li>可以包含浮动元素</li><li>不被浮动元素覆盖</li><li>阻止父子元素的margin折叠</li></ol><blockquote><p> display,float,position的关系</p></blockquote><ol><li>如果<code>display</code>为none，那么position和float都不起作用，这种情况下元素不产生框</li><li>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。</li><li>否则，如果float不是none，框是浮动的，display根据下表进行调整</li><li>否则，如果元素是根元素，display根据下表进行调整</li><li>其他情况下display的值为指定值<br>总结起来：<strong>绝对定位、浮动、根元素都需要调整<code>display</code></strong><br><img src="http://p3th9y4pk.bkt.clouddn.com/display-adjust.png" alt="display转换规则"></li></ol><blockquote><p> 外边距折叠(collapsing margins)<br>毗邻的两个或多个<code>margin</code>会合并成一个margin，叫做外边距折叠。规则如下：</p></blockquote><ol><li>两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠</li><li>浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li><li>元素自身的margin-bottom和margin-top相邻时也会折叠</li></ol><blockquote><p> 如何确定一个元素的包含块(containing block)</p></blockquote><ol><li>根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。</li><li><code>position</code>为<code>relative</code>或者<code>static</code>的元素，它的包含块由最近的块级（<code>display</code>为<code>block</code>,<code>list-item</code>, <code>table</code>）祖先元素的<strong>内容框</strong>组成</li><li>如果元素<code>position</code>为<code>fixed</code>。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area</li><li><p>如果元素<code>position</code>为<code>absolute</code>，它的包含块由祖先元素中最近一个<code>position</code>为<code>relative</code>,<code>absolute</code>或者<code>fixed</code>的元素产生，规则如下：</p><ul><li>如果祖先元素为行内元素，the containing block is the bounding box around the <strong>padding boxes</strong> of the first and the last inline boxes generated for that element.</li><li><p>其他情况下包含块由祖先节点的<strong>padding edge</strong>组成</p><p>如果找不到定位的祖先元素，包含块为<strong>初始包含块</strong></p></li></ul></li></ol><blockquote><p> stacking context,布局规则<br>z轴上的默认层叠顺序如下（从下到上）：</p></blockquote><ol><li>根元素的边界和背景</li><li>常规流中的元素按照html中顺序</li><li>浮动块</li><li>positioned元素按照html中出现顺序</li></ol><p>如何创建stacking context：</p><ol><li>根元素</li><li>z-index不为auto的定位元素</li><li>a flex item with a z-index value other than ‘auto’</li><li>opacity小于1的元素</li><li>在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context</li></ol><blockquote><p> 如何水平居中一个元素</p><ul><li>如果需要居中的元素为<strong>常规流中inline元素</strong>，为父元素设置<code>text-align: center;</code>即可实现</li><li>如果需要居中的元素为<strong>常规流中block元素</strong>，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置<code>text-align: center;</code>,再给子元素恢复需要的值</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    aaaaaa aaaaaa a a a a a a a a</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background: #DDD;</span><br><span class="line">        text-align: center; /* 3 */</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">        width: 500px;      /* 1 */</span><br><span class="line">        text-align: left;  /* 3 */</span><br><span class="line">        margin: 0 auto;    /* 2 */</span><br><span class="line"></span><br><span class="line">        background: purple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>如果需要居中的元素为<strong>浮动元素</strong>，1）为元素设置宽度，2）<code>position: relative;</code>，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    aaaaaa aaaaaa a a a a a a a a</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background: #DDD;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">        width: 500px;         /* 1 */</span><br><span class="line">        float: left;</span><br><span class="line"></span><br><span class="line">        position: relative;   /* 2 */</span><br><span class="line">        left: 50%;            /* 3 */</span><br><span class="line">        margin-left: -250px;  /* 4 */</span><br><span class="line"></span><br><span class="line">        background-color: purple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>如果需要居中的元素为<strong>绝对定位元素</strong>，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    aaaaaa aaaaaa a a a a a a a a</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background: #DDD;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">        width: 800px;</span><br><span class="line"></span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        margin-left: -400px;</span><br><span class="line"></span><br><span class="line">        background-color: purple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>如果需要居中的元素为<strong>绝对定位元素</strong>，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    aaaaaa aaaaaa a a a a a a a a</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background: #DDD;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">        width: 800px;</span><br><span class="line"></span><br><span class="line">        position: absolute;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line"></span><br><span class="line">        background-color: purple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 如何竖直居中一个元素<br>参考资料：<a href="http://www.vanseodesign.com/css/vertical-centering/" target="_blank" rel="noopener">6 Methods For Vertical Centering With CSS</a>。 <a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="noopener">盘点8种CSS实现垂直居中</a></p></blockquote><ul><li>需要居中元素为<strong>单行文本</strong>，为包含文本的元素设置大于<code>font-size</code>的<code>line-height</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;text&quot;&gt;center text&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.text &#123;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="javascript概念部分"><a href="#javascript概念部分" class="headerlink" title="javascript概念部分"></a>javascript概念部分</h3><blockquote><p> DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</p></blockquote><ul><li>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中<strong>设置的属性</strong></li><li>e.propName通常是在HTML文档中访问特定元素的<strong>特性</strong>，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问</li><li>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）</li><li>e.propName返回值可能是字符串、布尔值、对象、undefined等</li><li>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性</li><li>一些布尔属性<code>&lt;input hidden/&gt;</code>的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property</li><li>像<code>&lt;a href=&quot;../index.html&quot;&gt;link&lt;/a&gt;</code>中href属性，转换成property的时候需要通过转换得到完整URL</li><li>一些attribute和property不是一一对应如：form控件中<code>&lt;input value=&quot;hello&quot;/&gt;</code>对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</li></ul><blockquote><p> offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</p></blockquote><ul><li>offsetWidth/offsetHeight返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li><li>clientWidth/clientHeight返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li><li>scrollWidth/scrollHeight返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li></ul><p><a href="http://msdn.microsoft.com/en-us/library/ie/hh781509(v=vs.85" target="_blank" rel="noopener">Measuring Element Dimension and Location with CSSOM in Windows Internet Explorer 9</a>.aspx)</p><p><img src="http://p3th9y4pk.bkt.clouddn.com/element-size.png" alt="元素尺寸"></p><blockquote><p> XMLHttpRequest通用属性和方法</p></blockquote><ol><li><code>readyState</code>:表示请求状态的整数，取值：<ul><li>UNSENT（0）：对象已创建</li><li>OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求</li><li>HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到</li><li>LOADING(3)：响应体正在接收</li><li>DONE(4)：数据传输完成或者传输产生错误</li></ul></li><li><code>onreadystatechange</code>：readyState改变时调用的函数</li><li><code>status</code>：服务器返回的HTTP状态码（如，200， 404）</li><li><code>statusText</code>:服务器返回的HTTP状态信息（如，OK，No Content）</li><li><code>responseText</code>:作为字符串形式的来自服务器的完整响应</li><li><code>responseXML</code>: Document对象，表示服务器的响应解析成的XML文档</li><li><code>abort()</code>:取消异步HTTP请求</li><li><code>getAllResponseHeaders()</code>: 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行</li><li><code>getResponseHeader(headerName)</code>:返回headName对应的报头值</li><li><code>open(method, url, asynchronous [, user, password])</code>:初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证</li><li><code>setRequestHeader(name, value)</code>:设置HTTP报头</li><li><code>send(body)</code>:对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</li></ol><blockquote><p> focus/blur与focusin/focusout的区别与联系</p></blockquote><ol><li>focus/blur不冒泡，focusin/focusout冒泡</li><li>focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true)</li><li>可获得焦点的元素：<ol><li>window</li><li>链接被点击或键盘操作</li><li>表单空间被点击或键盘操作</li><li>设置<code>tabindex</code>属性的元素被点击或键盘操作</li></ol></li></ol><blockquote><p> mouseover/mouseout与mouseenter/mouseleave的区别与联系</p></blockquote><ol><li>mouseover/mouseout是标准事件，<strong>所有浏览器都支持</strong>；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持</li><li>mouseover/mouseout是<strong>冒泡</strong>事件；mouseenter/mouseleave<strong>不冒泡</strong>。需要为<strong>多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能</strong></li><li>标准事件模型中event.target表示发生移入/出的元素,<strong>vent.relatedTarget</strong>对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，<strong>event.toElement</strong>表示移出的目标元素，<strong>event.fromElement</strong>表示移入时的来源元素</li></ol><p>例子：鼠标从div#target元素移出时进行处理，判断逻辑如下：</p><pre><code>&lt;div id=&quot;target&quot;&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var target = document.getElementById(&apos;target&apos;);if (target.addEventListener) {  target.addEventListener(&apos;mouseout&apos;, mouseoutHandler, false);} else if (target.attachEvent) {  target.attachEvent(&apos;onmouseout&apos;, mouseoutHandler);}function mouseoutHandler(e) {  e = e || window.event;  var target = e.target || e.srcElement;  // 判断移出鼠标的元素是否为目标元素  if (target.id !== &apos;target&apos;) {    return;  }  // 判断鼠标是移出元素还是移到子元素  var relatedTarget = event.relatedTarget || e.toElement;  while (relatedTarget !== target    &amp;&amp; relatedTarget.nodeName.toUpperCase() !== &apos;BODY&apos;) {    relatedTarget = relatedTarget.parentNode;  }  // 如果相等，说明鼠标在元素内部移动  if (relatedTarget === target) {    return;  }  // 执行需要操作  //alert(&apos;鼠标移出&apos;);}&lt;/script&gt;</code></pre><blockquote><p> sessionStorage,localStorage,cookie区别</p></blockquote><ol><li>都会在浏览器端保存，有大小限制，同源限制</li><li>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器</li><li>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie</li><li>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除</li><li>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享</li><li>localStorage的修改会促发其他文档窗口的update事件</li><li>cookie有secure属性要求HTTPS传输</li><li>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</li></ol><blockquote><p> javascript跨域通信<br>同源：两个文档同源需满足</p></blockquote><ol><li>协议相同</li><li>域名相同</li><li>端口相同</li></ol><p>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法</p><ul><li>如果是log之类的简单<strong>单项通信</strong>，新建<code>&lt;img&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;link&gt;</code>,<code>&lt;iframe&gt;</code>元素，通过src，href属性设置为目标url。实现跨域请求</li><li>如果请求<strong>json数据</strong>，使用<code>&lt;script&gt;</code>进行jsonp请求</li><li>现代浏览器中<strong>多窗口通信</strong>使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用</li><li>内部服务器代理请求跨域url，然后返回数据</li><li>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部<strong><code>Access-Control-Allow-Origin: *</code></strong>即可像普通ajax一样访问跨域资源</li></ul><blockquote><p> javascript有哪几种数据类型<br>六种基本数据类型</p></blockquote><ul><li>undefined</li><li>null</li><li>string</li><li>boolean</li><li>number</li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">symbol</a>(ES6)</li></ul><p>一种引用类型</p><ul><li>Object</li></ul><blockquote><p> 什么闭包,闭包有什么用<br><strong>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量</strong>。闭包作用域链通常包括三个部分：</p></blockquote><ol><li>函数本身作用域。</li><li>闭包定义时的作用域。</li><li>全局作用域。</li></ol><p>闭包常见用途：</p><ol><li>创建特权方法用于访问控制</li><li>事件处理程序及回调</li></ol><blockquote><p> javascript有哪几种方法定义函数</p></blockquote><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" target="_blank" rel="noopener">函数声明表达式</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">function操作符</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">Function 构造函数</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/arrow_functions" target="_blank" rel="noopener">ES6:arrow function</a></li></ol><p>重要参考资料：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope" target="_blank" rel="noopener">MDN:Functions_and_function_scope</a></p><blockquote><p> 应用程序存储和离线web应用<br>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:<code>&lt;html manifest=&quot;myapp.appcache&quot;&gt;</code>，其中后缀名只是一个约定，真正识别方式是通过<code>text/cache-manifest</code>作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为<code>CACHE MANIFEST</code>，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：<code>CACHE</code>:为默认类型。<code>NETWORK</code>：表示资源从不缓存。 <code>FALLBACK</code>:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">myapp.html</span><br><span class="line">myapp.css</span><br><span class="line">myapp.js</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">videos/ offline_help.html</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">cgi/</span><br></pre></td></tr></table></figure><blockquote><p> 客户端存储localStorage和sessionStorage</p></blockquote><ul><li>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前</li><li>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。</li><li>Storage对象通常被当做普通javascript对象使用：<strong>通过设置属性来存取字符串值</strong>，也可以通过<strong>setItem(key, value)设置</strong>，<strong>getItem(key)读取</strong>，<strong>removeItem(key)删除</strong>，<strong>clear()删除所有数据</strong>，<strong>length表示已存储的数据项数目</strong>，<strong>key(index)返回对应索引的key</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&apos;x&apos;, 1); // storge x-&gt;1</span><br><span class="line">localStorage.getItem(&apos;x); // return value of x</span><br><span class="line"></span><br><span class="line">// 枚举所有存储的键值对</span><br><span class="line">for (var i = 0, len = localStorage.length; i &lt; len; ++i ) &#123;</span><br><span class="line">    var name = localStorage.key(i);</span><br><span class="line">    var value = localStorage.getItem(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(&apos;x&apos;); // remove x</span><br><span class="line">localStorage.clear();  // remove all data</span><br></pre></td></tr></table></figure><blockquote><p> cookie及其操作</p></blockquote><ul><li>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。</li><li>通过读写cookie检测是否支持</li><li>cookie属性有<strong>名</strong>，<strong>值</strong>，<strong>max-age</strong>，<strong>path</strong>, <strong>domain</strong>，<strong>secure</strong>；</li><li>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置<strong>max-age=seconds</strong>属性告诉浏览器cookie有效期</li><li>cookie作用域通过<strong>文档源</strong>和<strong>文档路径</strong>来确定，通过<strong>path</strong>和<strong>domain</strong>进行配置，web页面同目录或子目录文档都可访问</li><li>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下</li><li>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &apos;name=qiu; max-age=9999; path=/; domain=domain; secure&apos;;</span><br><span class="line"></span><br><span class="line">document.cookie = &apos;name=aaa; path=/; domain=domain; secure&apos;;</span><br><span class="line">// 要改变cookie的值，需要使用相同的名字、路径和域，新的值</span><br><span class="line">// 来设置cookie，同样的方法可以用来改变有效期</span><br><span class="line"></span><br><span class="line">// 设置max-age为0可以删除指定cookie</span><br><span class="line"></span><br><span class="line">//读取cookie，访问document.cookie返回键值对组成的字符串，</span><br><span class="line">//不同键值对之间用&apos;; &apos;分隔。通过解析获得需要的值</span><br></pre></td></tr></table></figure><p><a href="https://github.com/qiu-deqing/google/blob/master/module/js/cookieUtil.js" target="_blank" rel="noopener">cookieUtil.js</a>：自己写的cookie操作工具</p><blockquote><p> javascript有哪些方法定义对象</p></blockquote><ol><li>对象字面量： <code>var obj = {};</code></li><li>构造函数： <code>var obj = new Object();</code></li><li>Object.create(): <code>var obj = Object.create(Object.prototype);</code></li></ol><blockquote><p> ===运算符判断相等的流程是怎样的</p></blockquote><ol><li>如果两个值不是相同类型，它们不相等</li><li>如果两个值都是null或者都是undefined，它们相等</li><li>如果两个值都是布尔类型true或者都是false，它们相等</li><li>如果其中有一个是<strong>NaN</strong>，它们不相等</li><li>如果都是数值型并且数值相等，他们相等， -0等于0</li><li>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等</li><li>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</li></ol><blockquote><p> ==运算符判断相等的流程是怎样的</p></blockquote><ol><li>如果两个值类型相同，按照===比较方法进行比较</li><li>如果类型不同，使用如下规则进行比较<ol><li>如果其中一个值是null，另一个是undefined，它们相等</li><li>如果一个值是<strong>数字</strong>另一个是<strong>字符串</strong>，将<strong>字符串转换为数字</strong>进行比较</li><li>如果有布尔类型，将<strong>true转换为1，false转换为0</strong>，然后用==规则继续比较</li><li>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较</li><li><strong>其他所有情况都认为不相等</strong></li></ol></li></ol><blockquote><p> 对象到字符串的转换步骤</p></blockquote><ol><li>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果</li><li>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果</li><li>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</li></ol><blockquote><p> 对象到数字的转换步骤</p></blockquote><pre><code>1. 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果2. 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果3. 否则，throws a TypeError</code></pre><blockquote><p> &lt;,&gt;,&lt;=,&gt;=的比较规则</p></blockquote><p>所有比较运算符都支持任意类型，但是<strong>比较只支持数字和字符串</strong>，所以需要执行必要的转换然后进行比较，转换规则如下:</p><ol><li>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错</li><li>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）</li><li>否则，如果有一个操作数不是字符串，<strong>将两个操作数转换为数字</strong>进行比较</li></ol><blockquote><p> +运算符工作流程</p><ol><li>如果有操作数是对象，转换为原始值</li><li>此时如果有<strong>一个操作数是字符串</strong>，其他的操作数都转换为字符串并执行连接</li><li>否则：<strong>所有操作数都转换为数字并执行加法</strong></li></ol></blockquote><blockquote><p> 函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</p></blockquote><ul><li>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象</li><li>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参</li><li>arguments.length为实参的个数（Function.length表示形参长度）</li><li>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化</li><li>arguments.caller为调用当前函数的函数（已被遗弃）</li><li>转换为数组：<code>var args = Array.prototype.slice.call(arguments, 0);</code></li></ul><blockquote><p> DOM事件模型是如何的,编写一个EventUtil工具类实现事件管理兼容</p></blockquote><ul><li>DOM事件包含捕获（capture）和冒泡（bubble）两个阶段：捕获阶段事件从window开始触发事件然后通过祖先节点一次传递到触发事件的DOM元素上；冒泡阶段事件从初始元素依次向祖先节点传递直到window</li><li>标准事件监听elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler接收保存事件信息的event对象作为参数，event.target为触发事件的对象，handler调用上下文this为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递</li><li>老版本IE事件监听elem.attachEvent(‘on’+type, handler)/elem.detachEvent(‘on’+type, handler)：handler不接收event作为参数，事件信息保存在window.event中，触发事件的对象为event.srcElement，handler执行上下文this为window使用闭包中调用handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue为false时取消事件默认行为，event.cancleBubble为true时取消时间传播</li><li>通常利用事件冒泡机制托管事件处理程序提高程序性能。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 跨浏览器事件处理工具。只支持冒泡。不支持捕获</span><br><span class="line"> * @author  (qiu_deqing@126.com)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var EventUtil = &#123;</span><br><span class="line">    getEvent: function (event) &#123;</span><br><span class="line">        return event || window.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: function (event) &#123;</span><br><span class="line">        return event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 返回注册成功的监听器，IE中需要使用返回值来移除监听器</span><br><span class="line">    on: function (elem, type, handler) &#123;</span><br><span class="line">        if (elem.addEventListener) &#123;</span><br><span class="line">            elem.addEventListener(type, handler, false);</span><br><span class="line">            return handler;</span><br><span class="line">        &#125; else if (elem.attachEvent) &#123;</span><br><span class="line">            var wrapper = function () &#123;</span><br><span class="line">              var event = window.event;</span><br><span class="line">              event.target = event.srcElement;</span><br><span class="line">              handler.call(elem, event);</span><br><span class="line">            &#125;;</span><br><span class="line">            elem.attachEvent(&apos;on&apos; + type, wrapper);</span><br><span class="line">            return wrapper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    off: function (elem, type, handler) &#123;</span><br><span class="line">        if (elem.removeEventListener) &#123;</span><br><span class="line">            elem.removeEventListener(type, handler, false);</span><br><span class="line">        &#125; else if (elem.detachEvent) &#123;</span><br><span class="line">            elem.detachEvent(&apos;on&apos; + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: function (event) &#123;</span><br><span class="line">        if (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; else if (&apos;returnValue&apos; in event) &#123;</span><br><span class="line">            event.returnValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation: function (event) &#123;</span><br><span class="line">        if (event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; else if (&apos;cancelBubble&apos; in event) &#123;</span><br><span class="line">            event.cancelBubble = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * keypress事件跨浏览器获取输入字符</span><br><span class="line">     * 某些浏览器在一些特殊键上也触发keypress，此时返回null</span><br><span class="line">     **/</span><br><span class="line">     getChar: function (event) &#123;</span><br><span class="line">        if (event.which == null) &#123;</span><br><span class="line">            return String.fromCharCode(event.keyCode);  // IE</span><br><span class="line">        &#125;</span><br><span class="line">        else if (event.which != 0 &amp;&amp; event.charCode != 0) &#123;</span><br><span class="line">            return String.fromCharCode(event.which);    // the rest</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return null;    // special key</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p> 评价一下三种方法实现继承的优缺点,并改进</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Shape() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Rect() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 方法1</span><br><span class="line">Rect.prototype = new Shape();</span><br><span class="line"></span><br><span class="line">// 方法2</span><br><span class="line">Rect.prototype = Shape.prototype;</span><br><span class="line"></span><br><span class="line">// 方法3</span><br><span class="line">Rect.prototype = Object.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line">Rect.prototype.area = function () &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法1：</p><ol><li>优点：正确设置原型链实现继承</li><li>优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值</li><li>缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改</li><li>缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置</li><li>总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化</li></ol><p>方法2：</p><ol><li>优点：正确设置原型链实现继承</li><li>缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类</li></ol><p>方法3：</p><ol><li>优点：正确设置原型链且避免方法1.2中的缺点</li><li>缺点：ES5方法需要注意兼容性</li></ol><p>改进：</p><ol><li>所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Rect() &#123;</span><br><span class="line">    Shape.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用新创建的对象替代子类默认原型，设置<code>Rect.prototype.constructor = Rect;</code>保证一致性</li><li>第三种方法的polyfill：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function create(obj) &#123;</span><br><span class="line">    if (Object.create) &#123;</span><br><span class="line">        return Object.create(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f() &#123;&#125;;</span><br><span class="line">    f.prototype = obj;</span><br><span class="line">    return new f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="javascript编程部分"><a href="#javascript编程部分" class="headerlink" title="javascript编程部分"></a>javascript编程部分</h3><blockquote><p> 请用原生js实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认0.2),使这个区域点击无效,要求兼容IE8+及各主流浏览器,遮罩层效果如下图所示:<br><img src="img/http://p3th9y4pk.bkt.clouddn.com/element-mask.jpg" alt="遮罩效果"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#target &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin: 40px;</span><br><span class="line">    background-color: tomato;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function addMask(elem, opacity) &#123;</span><br><span class="line">    opacity = opacity || 0.2;</span><br><span class="line"></span><br><span class="line">    var rect = elem.getBoundingClientRect();</span><br><span class="line">    var style = getComputedStyle(elem, null);</span><br><span class="line"></span><br><span class="line">    var mask = document.createElement(&apos;div&apos;);</span><br><span class="line">    mask.style.position = &apos;absolute&apos;;</span><br><span class="line">    var marginLeft = parseFloat(style.marginLeft);</span><br><span class="line">    mask.style.left = (elem.offsetLeft - marginLeft) + &apos;px&apos;;</span><br><span class="line">    var marginTop = parseFloat(style.marginTop);</span><br><span class="line">    mask.style.top = (elem.offsetTop - marginTop) + &apos;px&apos;;</span><br><span class="line">    mask.style.zIndex = 9999;</span><br><span class="line">    mask.style.opacity = &apos;&apos; + opacity;</span><br><span class="line">    mask.style.backgroundColor = &apos;#000&apos;;</span><br><span class="line"></span><br><span class="line">    mask.style.width = (parseFloat(style.marginLeft) +</span><br><span class="line">        parseFloat(style.marginRight) + rect.width) + &apos;px&apos;;</span><br><span class="line">    mask.style.height = (parseFloat(style.marginTop) +</span><br><span class="line">        parseFloat(style.marginBottom) + rect.height) + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line">    elem.parentNode.appendChild(mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target = document.getElementById(&apos;target&apos;);</span><br><span class="line">addMask(target);</span><br><span class="line"></span><br><span class="line">target.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];</span><br><span class="line">var date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(&apos;今天是星期&apos; + days[date.getDay()]);</span><br></pre></td></tr></table></figure><blockquote><p> 下面这段代码想要循环延时输出结果0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(i + &apos; &apos;);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能输出正确结果，因为循环中setTimeout接受的参数函数通过闭包访问变量i。javascript运行环境为单线程，setTimeout注册的函数需要等待线程空闲才能执行，此时for循环已经结束，i值为5.五个定时输出都是5<br>修改方法：将setTimeout放在函数立即调用表达式中，将i值作为参数传递给包裹函数，创建新闭包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(i + &apos; &apos;);</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 现有一个Page类,其原型对象上有许多以post开头的方法(如postMsg);另有一拦截函数chekc,只返回ture或false.请设计一个函数,该函数应批量改造原Page的postXXX方法,在保留其原有功能的同时,为每个postXXX方法增加拦截验证功能,当chekc返回true时继续执行原postXXX方法,返回false时不再执行原postXXX方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function Page() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Page.prototype = &#123;</span><br><span class="line">  constructor: Page,</span><br><span class="line"></span><br><span class="line">  postA: function (a) &#123;</span><br><span class="line">    console.log(&apos;a:&apos; + a);</span><br><span class="line">  &#125;,</span><br><span class="line">  postB: function (b) &#123;</span><br><span class="line">    console.log(&apos;b:&apos; + b);</span><br><span class="line">  &#125;,</span><br><span class="line">  postC: function (c) &#123;</span><br><span class="line">    console.log(&apos;c:&apos; + c);</span><br><span class="line">  &#125;,</span><br><span class="line">  check: function () &#123;</span><br><span class="line">    return Math.random() &gt; 0.5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function checkfy(obj) &#123;</span><br><span class="line">  for (var key in obj) &#123;</span><br><span class="line">    if (key.indexOf(&apos;post&apos;) === 0 &amp;&amp; typeof obj[key] === &apos;function&apos;) &#123;</span><br><span class="line">      (function (key) &#123;</span><br><span class="line">        var fn = obj[key];</span><br><span class="line">        obj[key] = function () &#123;</span><br><span class="line">          if (obj.check()) &#123;</span><br><span class="line">            fn.apply(obj, arguments);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;(key));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; // end checkfy()</span><br><span class="line"></span><br><span class="line">checkfy(Page.prototype);</span><br><span class="line"></span><br><span class="line">var obj = new Page();</span><br><span class="line"></span><br><span class="line">obj.postA(&apos;checkfy&apos;);</span><br><span class="line">obj.postB(&apos;checkfy&apos;);</span><br><span class="line">obj.postC(&apos;checkfy&apos;);</span><br></pre></td></tr></table></figure><blockquote><p> 完成下面的tool-tip<br><img src="http://p3th9y4pk.bkt.clouddn.com/tip-box.jpg" alt="xxx"></p></blockquote><blockquote><p> 编写javascript深度克隆函数deepClone</p></blockquote><pre><code>function deepClone(obj) {    var _toString = Object.prototype.toString;    // null, undefined, non-object, function    if (!obj || typeof obj !== &apos;object&apos;) {        return obj;    }    // DOM Node    if (obj.nodeType &amp;&amp; &apos;cloneNode&apos; in obj) {        return obj.cloneNode(true);    }    // Date    if (_toString.call(obj) === &apos;[object Date]&apos;) {        return new Date(obj.getTime());    }    // RegExp    if (_toString.call(obj) === &apos;[object RegExp]&apos;) {        var flags = [];        if (obj.global) { flags.push(&apos;g&apos;); }        if (obj.multiline) { flags.push(&apos;m&apos;); }        if (obj.ignoreCase) { flags.push(&apos;i&apos;); }        return new RegExp(obj.source, flags.join(&apos;&apos;));    }    var result = Array.isArray(obj) ? [] :        obj.constructor ? new obj.constructor() : {};    for (var key in obj ) {        result[key] = deepClone(obj[key]);    }    return result;}function A() {    this.a = a;}var a = {    name: &apos;qiu&apos;,    birth: new Date(),    pattern: /qiu/gim,    container: document.body,    hobbys: [&apos;book&apos;, new Date(), /aaa/gim, 111]};var c = new A();var b = deepClone(c);console.log(c.a === b.a);console.log(c, b);</code></pre><blockquote><p> 补充代码,鼠标单击Button1后将Button1移动到Button2的后面</p></blockquote><pre><code>&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;TEst&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;   &lt;input type=&quot;button&quot; id =&quot;button1&quot; value=&quot;1&quot; /&gt;   &lt;input type=&quot;button&quot; id =&quot;button2&quot; value=&quot;2&quot; /&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var btn1 = document.getElementById(&apos;button1&apos;);    var btn2 = document.getElementById(&apos;button2&apos;);    addListener(btn1, &apos;click&apos;, function (event) {        btn1.parentNode.insertBefore(btn2, btn1);    });    function addListener(elem, type, handler) {        if (elem.addEventListener) {            elem.addEventListener(type, handler, false);            return handler;        } else if (elem.attachEvent) {            function wrapper() {                var event = window.event;                event.target = event.srcElement;                handler.call(elem, event);            }            elem.attachEvent(&apos;on&apos; + type, wrapper);            return wrapper;        }    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p> 网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示”××年还剩××天××时××分××秒”</p></blockquote><pre><code>&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;TEst&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;span id=&quot;target&quot;&gt;&lt;/span&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 为了简化。每月默认30天    function getTimeString() {        var start = new Date();        var end = new Date(start.getFullYear() + 1, 0, 1);        var elapse = Math.floor((end - start) / 1000);        var seconds = elapse % 60 ;        var minutes = Math.floor(elapse / 60) % 60;        var hours = Math.floor(elapse / (60 * 60)) % 24;        var days = Math.floor(elapse / (60 * 60 * 24)) % 30;        var months = Math.floor(elapse / (60 * 60 * 24 * 30)) % 12;        var years = Math.floor(elapse / (60 * 60 * 24 * 30 * 12));        return start.getFullYear() + &apos;年还剩&apos; + years + &apos;年&apos; + months + &apos;月&apos; + days + &apos;日&apos;            + hours + &apos;小时&apos; + minutes + &apos;分&apos; + seconds + &apos;秒&apos;;    }    function domText(elem, text) {        if (text == undefined) {            if (elem.textContent) {                return elem.textContent;            } else if (elem.innerText) {                return elem.innerText;            }        } else {            if (elem.textContent) {                elem.textContent = text;            } else if (elem.innerText) {                elem.innerText = text;            } else {                elem.innerHTML = text;            }        }    }    var target = document.getElementById(&apos;target&apos;);    setInterval(function () {        domText(target, getTimeString());    }, 1000)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p> 完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组<br>如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var data =  [1, [2, [ [3, 4], 5], 6]];</span><br><span class="line"></span><br><span class="line">function flat(data, result) &#123;</span><br><span class="line">    var i, d, len;</span><br><span class="line">    for (i = 0, len = data.length; i &lt; len; ++i) &#123;</span><br><span class="line">        d = data[i];</span><br><span class="line">        if (typeof d === &apos;number&apos;) &#123;</span><br><span class="line">            result.push(d);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            flat(d, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = [];</span><br><span class="line">flat(data, result);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><blockquote><p> 如何判断一个对象是否为数组<br>如果浏览器支持Array.isArray()可以直接判断否则需进行必要判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断一个对象是否是数组，参数不是对象或者不是数组，返回false</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Object&#125; arg 需要测试是否为数组的对象</span><br><span class="line"> * @return &#123;Boolean&#125; 传入参数是数组返回true，否则返回false</span><br><span class="line"> */</span><br><span class="line">function isArray(arg) &#123;</span><br><span class="line">    if (typeof arg === &apos;object&apos;) &#123;</span><br><span class="line">        return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 请评价以下事件监听器代码并给出改进意见</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (window.addEventListener) &#123;</span><br><span class="line">  var addListener = function (el, type, listener, useCapture) &#123;</span><br><span class="line">    el.addEventListener(type, listener, useCapture);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">else if (document.all) &#123;</span><br><span class="line">  addListener = function (el, type, listener) &#123;</span><br><span class="line">    el.attachEvent(&apos;on&apos; + type, function () &#123;</span><br><span class="line">      listener.apply(el);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：浏览器功能检测实现跨浏览器DOM事件绑定</p><p>优点：</p><ol><li>测试代码只运行一次，根据浏览器确定绑定方法</li><li>通过<code>listener.apply(el)</code>解决IE下监听器this与标准不一致的地方</li><li>在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能</li></ol><p>缺点：</p><ol><li>document.all作为IE检测不可靠，应该使用if(el.attachEvent)</li><li>addListener在不同浏览器下API不一样</li><li><code>listener.apply</code>使this与标准一致但监听器无法移除</li><li>未解决IE下listener参数event。 target问题</li></ol><p>改进:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var addListener;</span><br><span class="line"></span><br><span class="line">if (window.addEventListener) &#123;</span><br><span class="line">  addListener = function (el, type, listener, useCapture) &#123;</span><br><span class="line">    el.addEventListener(type, listener, useCapture);</span><br><span class="line">    return listener;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">else if (window.attachEvent) &#123;</span><br><span class="line">  addListener = function (el, type, listener) &#123;</span><br><span class="line">    // 标准化this，event，target</span><br><span class="line">    var wrapper = function () &#123;</span><br><span class="line">      var event = window.event;</span><br><span class="line">      event.target = event.srcElement;</span><br><span class="line">      listener.call(el, event);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    el.attachEvent(&apos;on&apos; + type, wrapper);</span><br><span class="line">    return wrapper;</span><br><span class="line">    // 返回wrapper。调用者可以保存，以后remove</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 如何判断一个对象是否为函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式）</span><br><span class="line"> * 的typeof返回&apos;function&apos;，采用通用方法，否则采用优化方法</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Any&#125; arg 需要检测是否为函数的对象</span><br><span class="line"> * @return &#123;boolean&#125; 如果参数是函数，返回true，否则false</span><br><span class="line"> */</span><br><span class="line">function isFunction(arg) &#123;</span><br><span class="line">    if (arg) &#123;</span><br><span class="line">        if (typeof (/./) !== &apos;function&apos;) &#123;</span><br><span class="line">            return typeof arg === &apos;function&apos;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Object.prototype.toString.call(arg) === &apos;[object Function]&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // end if</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 编写一个函数接受url中query string为参数,返回解析后的Object,query string使用application/x-www-form-urlencoded编码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解析query string转换为对象，一个key有多个值时生成数组</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String&#125; query 需要解析的query字符串，开头可以是?，</span><br><span class="line"> * 按照application/x-www-form-urlencoded编码</span><br><span class="line"> * @return &#123;Object&#125; 参数解析后的对象</span><br><span class="line"> */</span><br><span class="line">function parseQuery(query) &#123;</span><br><span class="line">    var result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 如果不是字符串返回空对象</span><br><span class="line">    if (typeof query !== &apos;string&apos;) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 去掉字符串开头可能带的?</span><br><span class="line">    if (query.charAt(0) === &apos;?&apos;) &#123;</span><br><span class="line">        query = query.substring(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var pairs = query.split(&apos;&amp;&apos;);</span><br><span class="line">    var pair;</span><br><span class="line">    var key, value;</span><br><span class="line">    var i, len;</span><br><span class="line"></span><br><span class="line">    for (i = 0, len = pairs.length; i &lt; len; ++i) &#123;</span><br><span class="line">        pair = pairs[i].split(&apos;=&apos;);</span><br><span class="line">        // application/x-www-form-urlencoded编码会将&apos; &apos;转换为+</span><br><span class="line">        key = decodeURIComponent(pair[0]).replace(/\+/g, &apos; &apos;);</span><br><span class="line">        value = decodeURIComponent(pair[1]).replace(/\+/g, &apos; &apos;);</span><br><span class="line"></span><br><span class="line">        // 如果是新key，直接添加</span><br><span class="line">        if (!(key in result)) &#123;</span><br><span class="line">            result[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果key已经出现一次以上，直接向数组添加value</span><br><span class="line">        else if (isArray(result[key])) &#123;</span><br><span class="line">            result[key].push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        // key第二次出现，将结果改为数组</span><br><span class="line">        else &#123;</span><br><span class="line">            var arr = [result[key]];</span><br><span class="line">            arr.push(value);</span><br><span class="line">            result[key] = arr;</span><br><span class="line">        &#125; // end if-else</span><br><span class="line">    &#125; // end for</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isArray(arg) &#123;</span><br><span class="line">    if (arg &amp;&amp; typeof arg === &apos;object&apos;) &#123;</span><br><span class="line">        return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">console.log(parseQuery(&apos;sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8&apos;));</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><blockquote><p> 解析一个完整的url,返回Object包含域与window.location相同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解析一个url并生成window.location对象中包含的域</span><br><span class="line"> * location:</span><br><span class="line"> * &#123;</span><br><span class="line"> *      href: &apos;包含完整的url&apos;,</span><br><span class="line"> *      origin: &apos;包含协议到pathname之前的内容&apos;,</span><br><span class="line"> *      protocol: &apos;url使用的协议，包含末尾的:&apos;,</span><br><span class="line"> *      username: &apos;用户名&apos;, // 暂时不支持</span><br><span class="line"> *      password: &apos;密码&apos;,  // 暂时不支持</span><br><span class="line"> *      host: &apos;完整主机名，包含:和端口&apos;,</span><br><span class="line"> *      hostname: &apos;主机名，不包含端口&apos;</span><br><span class="line"> *      port: &apos;端口号&apos;,</span><br><span class="line"> *      pathname: &apos;服务器上访问资源的路径/开头&apos;,</span><br><span class="line"> *      search: &apos;query string，?开头&apos;,</span><br><span class="line"> *      hash: &apos;#开头的fragment identifier&apos;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; url 需要解析的url</span><br><span class="line"> * @return &#123;Object&#125; 包含url信息的对象</span><br><span class="line"> */</span><br><span class="line">function parseUrl(url) &#123;</span><br><span class="line">    var result = &#123;&#125;;</span><br><span class="line">    var keys = [&apos;href&apos;, &apos;origin&apos;, &apos;protocol&apos;, &apos;host&apos;,</span><br><span class="line">                &apos;hostname&apos;, &apos;port&apos;, &apos;pathname&apos;, &apos;search&apos;, &apos;hash&apos;];</span><br><span class="line">    var i, len;</span><br><span class="line">    var regexp = /(([^:]+:)\/\/(([^:\/\?#]+)(:\d+)?))(\/[^?#]*)?(\?[^#]*)?(#.*)?/;</span><br><span class="line"></span><br><span class="line">    var match = regexp.exec(url);</span><br><span class="line"></span><br><span class="line">    if (match) &#123;</span><br><span class="line">        for (i = keys.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            result[keys[i]] = match[i] ? match[i] : &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 完成函数getViewportSize返回指定窗口的视口尺寸</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸</span><br><span class="line">**/</span><br><span class="line">function getViewportSize(w) &#123;</span><br><span class="line">    w = w || window;</span><br><span class="line"></span><br><span class="line">    // IE9及标准浏览器中可使用此标准方法</span><br><span class="line">    if (&apos;innerHeight&apos; in w) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            width: w.innerWidth,</span><br><span class="line">            height: w.innerHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var d = w.document;</span><br><span class="line">    // IE 8及以下浏览器在标准模式下</span><br><span class="line">    if (document.compatMode === &apos;CSS1Compat&apos;) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            width: d.documentElement.clientWidth,</span><br><span class="line">            height: d.documentElement.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // IE8及以下浏览器在怪癖模式下</span><br><span class="line">    return &#123;</span><br><span class="line">        width: d.body.clientWidth,</span><br><span class="line">        height: d.body.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 完成函数getScrollOffset返回窗口滚动条偏移量</p></blockquote><pre><code>/** * 获取指定window中滚动条的偏移量，如未指定则获取当前window * 滚动条偏移量 * * @param {window} w 需要获取滚动条偏移量的窗口 * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量 */function getScrollOffset(w) {    w =  w || window;    // 如果是标准浏览器    if (w.pageXOffset != null) {        return {            x: w.pageXOffset,            y: w.pageYOffset        };    }    // 老版本IE，根据兼容性不同访问不同元素    var d = w.document;    if (d.compatMode === &apos;CSS1Compat&apos;) {        return {            x: d.documentElement.scrollLeft,            y: d.documentElement.scrollTop        }    }    return {        x: d.body.scrollLeft,        y: d.body.scrollTop    };}</code></pre><blockquote><p> 现有一个字符串richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个img元素的p标签增加一个叫pic的class.请编写代码实现.可以使用jQuery或KISSY.</p></blockquote><pre><code>function richText(text) {    var div = document.createElement(&apos;div&apos;);    div.innerHTML = text;    var p = div.getElementsByTagName(&apos;p&apos;);    var i, len;    for (i = 0, len = p.length; i &lt; len; ++i) {        if (p[i].getElementsByTagName(&apos;img&apos;).length === 1) {            p[i].classList.add(&apos;pic&apos;);        }    }    return div.innerHTML;}</code></pre><blockquote><p> 请实现一个Event类,继承自此类的对象都会拥有两个方法on,off,once和trigger</p></blockquote><pre><code>function Event() {    if (!(this instanceof Event)) {        return new Event();    }    this._callbacks = {};}Event.prototype.on = function (type, handler) {    this_callbacks = this._callbacks || {};    this._callbacks[type] = this.callbacks[type] || [];    this._callbacks[type].push(handler);    return this;};Event.prototype.off = function (type, handler) {    var list = this._callbacks[type];    if (list) {        for (var i = list.length; i &gt;= 0; --i) {            if (list[i] === handler) {                list.splice(i, 1);            }        }    }    return this;};Event.prototype.trigger = function (type, data) {    var list = this._callbacks[type];    if (list) {        for (var i = 0, len = list.length; i &lt; len; ++i) {            list[i].call(this, data);        }    }};Event.prototype.once = function (type, handler) {    var self = this;    function wrapper() {        handler.apply(self, arguments);        self.off(type, wrapper);    }    this.on(type, wrapper);    return this;};</code></pre><blockquote><p> 编写一个函数将列表子元素顺序反转</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;target&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var target = document.getElementById(&apos;target&apos;);</span><br><span class="line">    var i;</span><br><span class="line">    var frag = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">    for (i = target.children.length - 1; i &amp;gt;= 0; --i) &#123;</span><br><span class="line">        frag.appendChild(target.children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    target.appendChild(frag);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 以下函数的作用是?空白区域应该填写什么</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// define</span><br><span class="line">(function (window) &#123;</span><br><span class="line">    function fn(str) &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn.prototype.format = function () &#123;</span><br><span class="line">        var arg = __1__;</span><br><span class="line">        return this.str.replace(__2__, function (a, b) &#123;</span><br><span class="line">            return arg[b] || &apos;&apos;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    window.fn = fn;</span><br><span class="line">&#125;)(window);</span><br><span class="line"></span><br><span class="line">// use</span><br><span class="line">(function () &#123;</span><br><span class="line">    var t = new fn(&apos;&lt;p&gt;&lt;a href=&quot;&#123;0&#125;&quot;&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;&apos;);</span><br><span class="line">    console.log(t.format(&apos;http://www.alibaba.com&apos;, &apos;Alibaba&apos;, &apos;Welcome&apos;));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>define部分定义一个简单的模板类，使用{}作为转义标记，中间的数字表示替换目标，format实参用来替换模板内标记<br>横线处填：</p><ol><li><code>Array.prototype.slice.call(arguments, 0)</code></li><li><code>/\{\s*(\d+)\s*\}/g</code></li></ol><blockquote><p> 编写一个函数实现form的序列化(即将一个表单中的键值序列化为可提交的字符串)</p></blockquote><pre><code>&lt;form id=&quot;target&quot;&gt;    &lt;select name=&quot;age&quot;&gt;        &lt;option value=&quot;aaa&quot;&gt;aaa&lt;/option&gt;        &lt;option value=&quot;bbb&quot; selected&gt;bbb&lt;/option&gt;    &lt;/select&gt;    &lt;select name=&quot;friends&quot; multiple&gt;        &lt;option value=&quot;qiu&quot; selected&gt;qiu&lt;/option&gt;        &lt;option value=&quot;de&quot;&gt;de&lt;/option&gt;        &lt;option value=&quot;qing&quot; selected&gt;qing&lt;/option&gt;    &lt;/select&gt;    &lt;input name=&quot;name&quot; value=&quot;qiudeqing&quot;&gt;    &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;11111&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;salery&quot; value=&quot;3333&quot;&gt;    &lt;textarea name=&quot;description&quot;&gt;description&lt;/textarea&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;football&quot;&gt;Football    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;Basketball    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked value=&quot;Female&quot;&gt;Female    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;Male&quot;&gt;Male&lt;/form&gt;&lt;script&gt;/** * 将一个表单元素序列化为可提交的字符串 * * @param {FormElement} form 需要序列化的表单元素 * @return {string} 表单序列化后的字符串 */function serializeForm(form) {  if (!form || form.nodeName.toUpperCase() !== &apos;FORM&apos;) {    return;  }  var result = [];  var i, len;  var field, fieldName, fieldType;  for (i = 0, len = form.length; i &lt; len; ++i) {    field = form.elements[i];    fieldName = field.name;    fieldType = field.type;    if (field.disabled || !fieldName) {      continue;    } // enf if    switch (fieldType) {      case &apos;text&apos;:      case &apos;password&apos;:      case &apos;hidden&apos;:      case &apos;textarea&apos;:        result.push(encodeURIComponent(fieldName) + &apos;=&apos; +            encodeURIComponent(field.value));        break;      case &apos;radio&apos;:      case &apos;checkbox&apos;:        if (field.checked) {          result.push(encodeURIComponent(fieldName) + &apos;=&apos; +            encodeURIComponent(field.value));        }        break;      case &apos;select-one&apos;:      case &apos;select-multiple&apos;:        for (var j = 0, jLen = field.options.length; j &lt; jLen; ++j) {          if (field.options[j].selected) {            result.push(encodeURIComponent(fieldName) + &apos;=&apos; +              encodeURIComponent(field.options[j].value || field.options[j].text));          }        } // end for        break;      case &apos;file&apos;:      case &apos;submit&apos;:        break; // 是否处理？      default:        break;    } // end switch  } // end for    return result.join(&apos;&amp;&apos;);}var form = document.getElementById(&apos;target&apos;);console.log(serializeForm(form));&lt;/script&gt;</code></pre><blockquote><p> 使用原生javascript给下面列表中的li节点绑定点击事件,点击时创建一个Object对象,兼容IE和标准浏览器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://11111&quot;&gt;111&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://2222&quot;&gt;222&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://333&quot;&gt;333&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://444&quot;&gt;444&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">Object:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot;: 1,</span><br><span class="line">    &quot;name&quot;: &quot;111&quot;,</span><br><span class="line">    &quot;link&quot;: &quot;http://1111&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>script:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil = &#123;</span><br><span class="line">    getEvent: function (event) &#123;</span><br><span class="line">        return event || window.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: function (event) &#123;</span><br><span class="line">        return event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 返回注册成功的监听器，IE中需要使用返回值来移除监听器</span><br><span class="line">    on: function (elem, type, handler) &#123;</span><br><span class="line">        if (elem.addEventListener) &#123;</span><br><span class="line">            elem.addEventListener(type, handler, false);</span><br><span class="line">            return handler;</span><br><span class="line">        &#125; else if (elem.attachEvent) &#123;</span><br><span class="line">            function wrapper(event) &#123;</span><br><span class="line">                return handler.call(elem, event);</span><br><span class="line">            &#125;;</span><br><span class="line">            elem.attachEvent(&apos;on&apos; + type, wrapper);</span><br><span class="line">            return wrapper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    off: function (elem, type, handler) &#123;</span><br><span class="line">        if (elem.removeEventListener) &#123;</span><br><span class="line">            elem.removeEventListener(type, handler, false);</span><br><span class="line">        &#125; else if (elem.detachEvent) &#123;</span><br><span class="line">            elem.detachEvent(&apos;on&apos; + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: function (event) &#123;</span><br><span class="line">        if (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; else if (&apos;returnValue&apos; in event) &#123;</span><br><span class="line">            event.returnValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation: function (event) &#123;</span><br><span class="line">        if (event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; else if (&apos;cancelBubble&apos; in event) &#123;</span><br><span class="line">            event.cancelBubble = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var DOMUtil = &#123;</span><br><span class="line">    text: function (elem) &#123;</span><br><span class="line">        if (&apos;textContent&apos; in elem) &#123;</span><br><span class="line">            return elem.textContent;</span><br><span class="line">        &#125; else if (&apos;innerText&apos; in elem) &#123;</span><br><span class="line">            return elem.innerText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    prop: function (elem, propName) &#123;</span><br><span class="line">        return elem.getAttribute(propName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var nav = document.getElementById(&apos;nav&apos;);</span><br><span class="line"></span><br><span class="line">EventUtil.on(nav, &apos;click&apos;, function (event) &#123;</span><br><span class="line">    var event = EventUtil.getEvent(event);</span><br><span class="line">    var target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line">    var children = this.children;</span><br><span class="line">    var i, len;</span><br><span class="line">    var anchor;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (i = 0, len = children.length; i &lt; len; ++i) &#123;</span><br><span class="line">        if (children[i] === target) &#123;</span><br><span class="line">            obj.index = i + 1;</span><br><span class="line">            anchor = target.getElementsByTagName(&apos;a&apos;)[0];</span><br><span class="line">            obj.name = DOMUtil.text(anchor);</span><br><span class="line">            obj.link = DOMUtil.prop(anchor, &apos;href&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alert(&apos;index: &apos; + obj.index + &apos; name: &apos; + obj.name +</span><br><span class="line">        &apos; link: &apos; + obj.link);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p> 有一个大数组,var a = [‘1’, ‘2’, ‘3’, …];a的长度是100,内容填充随机整数的字符串.请先构造此数组a,然后设计一个算法将其内容去重</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 数组去重</span><br><span class="line">**/</span><br><span class="line">function normalize(arr) &#123;</span><br><span class="line">    if (arr &amp;&amp; Array.isArray(arr)) &#123;</span><br><span class="line">        var i, len, map = &#123;&#125;;</span><br><span class="line">        for (i = arr.length; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (arr[i] in map) &#123;</span><br><span class="line">                arr.splice(i, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map[arr[i]] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 用100个随机整数对应的字符串填充数组。</span><br><span class="line">**/</span><br><span class="line">function fillArray(arr, start, end) &#123;</span><br><span class="line">    start = start == undefined ? 1 : start;</span><br><span class="line">    end = end == undefined ?  100 : end;</span><br><span class="line"></span><br><span class="line">    if (end &lt;= start) &#123;</span><br><span class="line">        end = start + 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var width = end - start;</span><br><span class="line">    var i;</span><br><span class="line">    for (i = 100; i &gt;= 1; --i) &#123;</span><br><span class="line">        arr.push(&apos;&apos; + (Math.floor(Math.random() * width) + start));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var input = [];</span><br><span class="line">fillArray(input, 1, 100);</span><br><span class="line">input.sort(function (a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(input);</span><br><span class="line"></span><br><span class="line">normalize(input);</span><br><span class="line">console.log(input);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;个人收集的前端知识点、问题和答案，参考答案仅代表个人观点，方便复习，目录如下，通过文档内搜索目录可快速定位章节。&lt;/p&gt;
&lt;h3 id=&quot;HTML，HTTP，web综合&quot;&gt;&lt;a href=&quot;#HTML，HTTP，web综合&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>三星 Galaxy 9使用体验</title>
    <link href="http://datalearn.top/2018/02/26/S901/"/>
    <id>http://datalearn.top/2018/02/26/S901/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-07-30T16:32:02.481Z</updated>
    
    <content type="html"><![CDATA[<p>在今年的世界移动通信大会上，三星在2月26日正式发布了Galaxy S9和Galaxy S9 Plus。<br>机身采用玻璃加金属的设计与去年的Galaxy S8和S8 +几乎完全相同，但是相机却变得更好了，没错<br>这次Galaxy S9系列最主要的升级就是它的相机。</p><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>S9有5.8英寸显示屏，S 9Plus有6.2英寸大屏幕。两款机型都采用18.5：9宽高比Super AMOLED显示屏，并具有相同的2,960 x 1,440分辨率。<br>S9的屏幕尺寸为每英寸570像素，S9 +的屏幕尺寸为529 ppi。<br>屏幕素质依然延续了三星优秀的品质。<br>辛亏三星没有模仿iPhone X的刘海，这点值得赞赏，不过三星历来都不会抄袭iPhone的设计。<br><img src="http://p3th9y4pk.bkt.clouddn.com/S902.jpg" alt=""></p><h3 id="小变化"><a href="#小变化" class="headerlink" title="小变化"></a>小变化</h3><p>指纹传感器已经移动到相机下方的更易接近的位置。在S8上，传感器位置太高，如果没有长手指，很难触及。它的位置在相机的右侧也容易意外弄脏镜头。将传感器放在背后仍然存在问题，但S9的传感器总体上处于更好的位置。<br>值得一提的是这两款手机背面已经配备了心率传感器、血氧饱和度传感器、紫外线传感器、血压传感器等，以帮助用户监测自身健康状况。<br><img src="http://p3th9y4pk.bkt.clouddn.com/S905.jpg" alt=""><br>S9还加入了立体扬声器，就像在iPhone上一样，立体声扬声器从充电端口旁边的听筒和扬声器中发出。<br>三星表示，扬声器由AKG调教，比Galaxy S8扬声器大1.4倍。立体声扬声器还支持杜比全景声3D模拟环绕声。在S8的并排聆听测试中，S9的立体声扬声器确实听起来更加丰富和响亮。</p><p>三星今年还改进了面部解锁，在去年的手机上，您可以使用虹膜扫描仪或面部解锁来解锁它。虹膜扫描仪更安全，可与三星Pay一起使用，但它常常在光线明亮的情况下正常工作。另一方面，脸部解锁更快解锁，但不太安全，因此不支持三星支付，并且在黑暗中无法正常工作。<br><img src="http://p3th9y4pk.bkt.clouddn.com/S903.jpg" alt=""></p><p>为了解决这个问题，三星在S9上增加了一项新的“智能扫描”功能，它可以让您两全其美。现在，如果您已设置了虹膜扫描仪和脸部解锁，手机会根据照明自动检测使用哪一个。这项功能的变化对大多数用户来说还是很贴心的。</p><h3 id="提高的相机"><a href="#提高的相机" class="headerlink" title="提高的相机"></a>提高的相机</h3><p>S9和S9 +的最大升级是后置摄像头。鉴于所有智能手机相机都有固定光圈镜头，S9和S9 +的1200万像素相机是具有两个光圈和OIS（光学防抖）的全新“超级双像素” 拍摄手机。</p><p>在S9上，相机根据拍摄条件自动在两个光圈之间切换。如果有足够的光线（如日光照片），则会选择f / 2.4光圈，以便照片从角落到角落锐利。但是如果场景太暗，相机会切换到f / 1.5光圈，让更多光线进入。它是一个或另一个; 没有办法选择两者之间的孔径。</p><p>在实际操作中，我没有机会在任何现实场景中测试双光圈。但从理论上讲，这使得S9和S9 +的相机更像是一个真正的相机，它通常带有一个可调节光圈的镜头，该光圈可以加宽，让更多光线变窄，让光线更少。<br> <img src="http://p3th9y4pk.bkt.clouddn.com/QQ20180228-212852@2x.png" alt=""><br>在S9 +上，有一个双摄像头系统。第二台相机位于主摄像头的正下方，具有f / 2.4光圈，并包含光学防抖功能。双摄像头就像Note 8一样工作。您可以使用带有模糊背景的“Live Focus”照片，然后调整模糊强度，或者同时拍摄Live Focus照片和广角照片。</p><p>还有一种花式的“多帧”技术，它需要三组四帧来减少图像噪声。这与通过合成多张不同曝光的照片创建具有更大动态范围的单张照片创建HDR（高动态范围）照片相似。 </p><p>与S8拍摄的照片相比，这种多帧技术可以减少30％的图像噪点。</p><h3 id="慢动作视频和AR表情"><a href="#慢动作视频和AR表情" class="headerlink" title="慢动作视频和AR表情"></a>慢动作视频和AR表情</h3><p>对于视频而言，超高速双像素相机传感器可以以960帧/秒的高清分辨率拍​​摄慢动作视频。从这个角度来看，iPhone X只能拍摄240帧/秒的慢动作。其他像索尼Xperia XZ这样的手机已经能够以960 fps的速度拍摄慢镜头，但是他们不使用设备上的AI来检测视频中的动作，并且只在那一刻持续时间内放慢视频速度。<br><img src="http://p3th9y4pk.bkt.clouddn.com/S906.jpg" alt=""></p><p>手机前面内置一个800万像素的摄像头，带有自动对焦的f / 1.7光圈。但是我最喜欢的功能是自拍相机的AR X Emoji，这显然是iPhone X Animoji的翻版。</p><p>相机将根据您的喜好创建表情符号。它们有点像3D Bitmoji。你可以自定义你的脸，发型，甚至装备。然后，该软件根据您的AR表情符号创建具有不同表情的18个GIF，然后您可以随时随地分享它们。就像Animoji一样，您可以录制映射到脸上各个点的AR表情符号短视频剪辑。<br><img src="http://p3th9y4pk.bkt.clouddn.com/s907.jpg" alt=""></p><h3 id="配置规格"><a href="#配置规格" class="headerlink" title="配置规格"></a>配置规格</h3><p>虽然许多手机制造商正在减少耳机插孔和microSD卡插槽等功能，但S9仍然保留着这些功能。<br>S9和S9 +采用高通最新的骁龙845芯片，具有很多优势。S9配备4GB的RAM，而S9 +则配备6GB的RAM。这两款手机都配有64GB的存储空间。正如前面提到的，他们都有一个microSD卡插槽，可以增加额外的400GB存储空间。<br> <img src="http://p3th9y4pk.bkt.clouddn.com/S908.jpg" alt=""><br>三星貌似现在最注重的就是电池安全。S9的电池容量为3000 mAh，S9 +的电池容量为3,500 mAh。这些是与S8和S8 +相同的电池。考虑到三星以前尝试增加电池容量，最终导致Note 7爆炸，所以看到他们在这里保守并不奇怪。<br>当然，三星S9系列还有其它的优势，如IP68防水防尘，快速有线和无线充电以及3.5毫米耳机插孔。<br> <img src="http://p3th9y4pk.bkt.clouddn.com/S909.jpg" alt=""></p><h3 id="手机变电脑"><a href="#手机变电脑" class="headerlink" title="手机变电脑"></a>手机变电脑</h3><p>一些高端用户可能会喜欢这款新的DeX Pad。当连接到显示器，键盘和鼠标时，附件仍然可以将S9和S9 +转换为类似桌面的计算体验。但其新的平面设计还意味着，如果您只有监视器或电视（如在酒店中），则可以将手机的屏幕用作触控板或虚拟键盘。在我看来，它不能取代真正的鼠标。<br>DeX Pad当然不像S8和S8 +的直立式底座那么光滑，但它确实有一些前所未有的优势。例如，它可以以更高的2,560 x 1,440分辨率输出到显示器（以前的DeX只能输出1,920 x 1,080），耳机插孔现在可以进行私密聆听。<br> <img src="http://p3th9y4pk.bkt.clouddn.com/S911.jpg" alt=""><br>三星表示该配件是向后兼容的，这意味着它可以与S8和S8 +以及未来的手机配合使用。这款配件售价约为1000元左右.</p><h3 id="最好的语音助手Bixby"><a href="#最好的语音助手Bixby" class="headerlink" title="最好的语音助手Bixby"></a>最好的语音助手Bixby</h3><p>无论你喜欢与否，S9的左侧仍然有一个专用的Bixby按钮，三星不会让用户重新映射它以激活Google之类的其他助理，或者启动应用程序或快捷方式。<br> <img src="http://p3th9y4pk.bkt.clouddn.com/s921.png" alt=""><br>虽然我确信许多用户会喜欢看到三星弱化Bixby或者不再强调它的存在，但该公司并没有这样做。相反，它将Bixby的能力提高一倍，注入更多的智慧。<br>根据我们之前的测试Bixby的确要比其它的语音助手例如苹果的siri，微软的小娜要更加智能。</p><h3 id="售价"><a href="#售价" class="headerlink" title="售价"></a>售价</h3><p>我们再梳理一下配置信息：：</p><ul><li>处理器骁龙845和三星Exynos 9810（欧洲、中东、韩国）</li><li>S9内存4GB、S9+6GB</li><li>ROM：64GB\128GB\256GB（最高支持400GB扩展支持）</li><li>安卓8.0系统</li><li>S9电池为3000毫安时、S9+电池为3500毫安时</li><li>网络制式：支持4X4 MIMO / CA、LAA、LTE Cat.18<br>售价方面：<br><img src="http://p3th9y4pk.bkt.clouddn.com/S9111.png" width="100%" height="100%"><br>这是购买的链接：<br><a href="https://mall.jd.com/index-1000003443.html" target="_blank" rel="noopener">京东直达购买链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在今年的世界移动通信大会上，三星在2月26日正式发布了Galaxy S9和Galaxy S9 Plus。&lt;br&gt;机身采用玻璃加金属的设计与去年的Galaxy S8和S8 +几乎完全相同，但是相机却变得更好了，没错&lt;br&gt;这次Galaxy S9系列最主要的升级就是它的相机。&lt;
      
    
    </summary>
    
    
      <category term="手机" scheme="http://datalearn.top/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>三星 Galaxy Note8评测：机皇归来</title>
    <link href="http://datalearn.top/2018/02/08/note8/"/>
    <id>http://datalearn.top/2018/02/08/note8/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:21.006Z</updated>
    
    <content type="html"><![CDATA[<p>今年9月份发布的Galaxy Note 8没有让大家失望，再度扛起了安卓机皇的大旗，几乎在所有方面都达到了目前安卓手机的顶级水平。<br>不难看出，三星毫不留情地砍掉了一切华而不实的东西，而这些东西恐怕就是引发前代 Note 产品一系列问题的根源。新一代 Note 并不是各种新功能的“大杂烩”。这款手机的许多新特性或新功能都直接借鉴于最新发布的Galaxy S8。现在看来，剩余大部分新功能或新特性，主要是为了把 Note 8 作为一个更为高级的选项，与屏幕大小相当的 Galaxy S8+区分开来。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-0a8cb5f71649bd13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/699" alt=""><br>新款 Galaxy Note 其实是在智能手机行业最为坚实的一个基础上开发出来的。新增的特性或功能主要是为了让这款产品变得更好。</p><h3 id="1-全视曲面屏"><a href="#1-全视曲面屏" class="headerlink" title="1.全视曲面屏"></a>1.全视曲面屏</h3><p>三星Note 8拥有一块6.3英寸QHD分辨率18.5：9全视曲面屏。边框部分Note系列相比S系列更为方正，视觉效果更“全面”。三星之所以能做到这一点，部分原因是 Infinity Display——这是三星今年早些时候在 Galaxy S8 上面推出的屏幕。这种设计充分利用三星的曲面屏，帮助消除了手机几乎所有的侧边框。得益于此，机身正面的屏幕空间得到充分利用，而且相比传统智能手机屏幕，Infinity Display 显示效果更好。当然，超高清晰 2960X1440 像素屏幕也对提升显示效果大有裨益。三星仍然在这个方面寻求突破，将像素密度从 518ppi 略微提升至 521ppi。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-dd5ed80c3ca89fc5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br>三星Galaxy Note 8在标准模式下最大亮度为518Nits，最低亮度了2Nites，色温的话为6471K，极其接近标准的6500K，而色准方面，三星Galaxy Note 8的色彩还原度在同等价位的手机之中属于领先地位。当然近几年三星的手机屏幕素质一直都处于业界领先地位，Note 8也不例外。</p><h3 id="2-双光学防抖双摄"><a href="#2-双光学防抖双摄" class="headerlink" title="2.双光学防抖双摄"></a>2.双光学防抖双摄</h3><p>三星Note 8也采用了更具优势的广角+长焦模式，支持2倍光学变焦，其中，主摄像头光圈为F/1.7，副摄像头光圈F/2.4。主摄像头依旧采用的是Dual Pixel传感器，并且支持双摄像头OIS光学防抖。并且支持先拍照后对焦的功能。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-c980626a48cfb4df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/699" alt=""><br>​双摄像头还可以让三星抓住日益受欢迎的人造散景（faux bokeh）效果的潮流——这种效果通过模拟浅景深，在让某个物体变得模糊的同时，还能进一步突出主题。Note 8 在这个方面的策略令我印象非常深刻。得益于 Live Focus 功能，你一边可以使用模糊效果，一边还能保持照片的预览状态。Note 8 的摄像头还能保留分别在广角和放大模式下拍摄的两张一模一样的照片，这样一来，用户在拍完照片后仍然可以进行后期处理。</p><p>增加广角功能还意味着，相比预览照片，你可以捕捉到更多镜头外的东西，前提是你想要拍摄角度更全的画面。当然，已存照片数量增长一倍，还意味着存储空间也要翻一番，但 Note 8 的 64GB 内存和 microSD 卡插槽的实际作用仍然存在讨论的空间。同之前其他 Note 设备一样，Note 8 的确是一款摄像头功能极为突出的手机。</p><h3 id="3-S-Pen手写笔"><a href="#3-S-Pen手写笔" class="headerlink" title="3.S Pen手写笔"></a>3.S Pen手写笔</h3><p>Pen一直都是三星Note系列最为与众不同的地方，甚至可以说，S Pen就是三星Note系列的灵魂。去年，三星就把S Pen的压感级别提升到了4096级，而今年，三星又为我们带来了S Pen的新玩法。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-bfd0f3677d06a648.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-6d669f10707d818d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br>三星Note8的S Pen今年拥有主打两个特性：其一是息屏录入、另一个是live Message动态输入，其实就是用 S Pen 手写笔制作的 GIF 动画。也就是说，我们不仅能在熄屏的状态下直接录入文字，还可以把手动书写的过程以动图的形式分享给朋友，包括通过微信进行分享。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-5891e2bafecef128.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><h3 id="4-不够智能的智能语音助手"><a href="#4-不够智能的智能语音助手" class="headerlink" title="4.不够智能的智能语音助手"></a>4.不够智能的智能语音助手</h3><p>Bixby并不是首次出现在三星手机上——它是随年初的三星S8一同发布的。但在发布之后这一功能只在韩国和美国市场开放，而且它的语音功能也一直没有解锁。现在，Bixby终于随Note 8一起来了！三星将进行全球GalaxyS8/S8+用户的推送解锁语音助手Bixby功能，具体包括中国、英国、法国、澳大利亚、加拿大、南非等全球市场。</p><p>如果三星想要围绕它创建一个完整的生态系统，未来还有很长的路要走。我完全理解三星想追上 Siri、Alexa 和 Google Assistant 的迫切心情，但它不该现在就将仍然处于早期阶段的 Bixby 推向前台。对于许多用户来说，Note 8 机身左侧的 Bixby 按键可能只起到一个作用，那就是无时无刻不在提醒他们注意 Bixby 的短板。</p><h3 id="5-硬件配置"><a href="#5-硬件配置" class="headerlink" title="5.硬件配置"></a>5.硬件配置</h3><p>Note 8采用了骁龙835和Exynos 8895两个平台处理器，拥有6GB RAM、64/128/256GB ROM（支持扩展）。Note 8支持虹膜识别、指纹识别，电池容量为3300mAh。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-4a4bc519d30a4c80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/699" alt=""></p><p>三星降低了 Note 8 的电池容量——从 Note 7 的 3500 mAh 降至 3300mAh。在我对此提出疑问时，三星表示由于新的芯片组，电源效率提升，所以 Note 8 并不需要容量更大的电池。尽管处理器效率不断提升是事实，但我认为三星这样做完全是出于安全考虑。电池只是三星不断提升手机性能的最后一环。绝缘性和更小的指纹，可能也对电池效率的提升有帮助。当然，S Pen 占用的额外空间意味着三星不能将像 S8+上面那样大的电池集成于 Note 8。在这种情况下，当我们花更多钱购买屏幕更大、更优质的设备时，还是会有点失望的。</p><p>和强大的手机性能以及屏幕素质相比，三星Galaxy Note 8的续航时间就显然不尽如人意了，在统一标准的情况下续航时间为7小时50分钟，与Galaxy S8+接近.</p><h3 id="6-特色功能"><a href="#6-特色功能" class="headerlink" title="6.特色功能"></a>6.特色功能</h3><h5 id="防水、虹膜识别和无线充电"><a href="#防水、虹膜识别和无线充电" class="headerlink" title="防水、虹膜识别和无线充电"></a>防水、虹膜识别和无线充电</h5><p>Note 8支持IP68防水防尘、无线充电、NFC和三星Pay.采用USB Type-C接口、系统基于Android 7.1.1、采取最新的蓝牙5.0协议、并且保留3.5mm耳机口等等。</p><p>另外Note 8随机附带了AKG调制的耳机<br><img src="https://upload-images.jianshu.io/upload_images/1910724-302d41b42fe44c35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/699" alt=""></p><p>三星希望 Note 8 能让人忘记 Note 7 不堪回首的过去，Note 8 如今也面临着手机行业最为严格的检测标准。Note 8 是在一个坚实的基础上打造出来的，同时相比 Galaxy S 系列又有多项重大升级。三星仍然在想方设法，实现 Note 与其他大屏 Galaxy 手机的差异化，像两个后置摄像头这样的功能，肯定深受用户欢迎。</p><p>三星为中国消费者准备了三款配色的Galaxy Note8，分别是谜夜黑、旷野灰和星河蓝。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-20e1386c6ed06010.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><h3 id="售价"><a href="#售价" class="headerlink" title="售价"></a>售价</h3><p>64GB Galaxy Note8售价为6988元</p><p>128GB Galaxy Note8售价为7388元</p><p>256GB Galaxy Note8售价为7988元</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年9月份发布的Galaxy Note 8没有让大家失望，再度扛起了安卓机皇的大旗，几乎在所有方面都达到了目前安卓手机的顶级水平。&lt;br&gt;不难看出，三星毫不留情地砍掉了一切华而不实的东西，而这些东西恐怕就是引发前代 Note 产品一系列问题的根源。新一代 Note 并不是各
      
    
    </summary>
    
      <category term="数码评测" scheme="http://datalearn.top/categories/%E6%95%B0%E7%A0%81%E8%AF%84%E6%B5%8B/"/>
    
    
      <category term="手机" scheme="http://datalearn.top/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>iPhone X首发上手快速体验</title>
    <link href="http://datalearn.top/2018/02/01/iPhone%20X/"/>
    <id>http://datalearn.top/2018/02/01/iPhone X/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-07-30T16:32:04.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在今年9月13日，iPhone发布十周年之际，苹果隆重推出了十周年纪念版，iPhone X。<br>苹果称这是一款面向未来的手机，那么这款手机到底如何，值不值得我们以8388元的价格购入呢？<br>下面，我们将向你详细介绍这款十周年纪念版iPhone：<br>首先要说明的是iPhone X相对于iPhone 8系列仍然有很多相同的地方<br>比如说相同的A11处理器，同样采用64GB/256GB的存储空间，所以在性能上，这三款手机不会有太大区别。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-5e98c621b28de885.jpg" alt=""></p><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>没错，在iPhone X上那个经典的home圆形按钮已经被去掉了，因为前面板几乎都是屏幕了，除了顶部的那个刘海。<br>这是iPhone系列最近最激进的外观改变，不得不说我还是很喜欢它的。<br>除了外观比较漂亮之外，iPhone X的手感也是非常棒的。手机的不锈钢边框和覆盖在手机的前面和后面的玻璃进行了无缝的贴合，用手摸起来是感觉不到缝隙的。<br>iPhone X上5.8英寸OLED面板几乎完全覆盖手机的前面板，不得不说，这块屏幕给用户造成的视觉冲击是非常棒的。<br>iPhone X的屏幕相较于Galaxy Note 8而言显得更加柔和自然，Note8的屏幕的色彩比较鲜艳。<br>喜欢哪种屏幕就要看个人的喜好了。<br><img src="http://p3th9y4pk.bkt.clouddn.com/iphone%20X1.jpeg" alt=""><br>    不过有一点要提及的就是，屏幕上方的有一个包含了，一个700万像素的前置摄像头，一个扬声器，红外摄像头和前置传感器的刘海。前置摄像头和3D传感器作为手机的脸部ID认证系统的核心。这个刘海一开始看起来似乎是一个笨拙的难看的设计，但在使用手机几个小时后，我就不再注意这个刘海了。毕竟，我使用手机的时候，基本都是在和这块屏幕中间部分做交互，所以不会一直关注这个额头。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-996716b811301827?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br>    由于iPhone X的屏幕尺寸是将近2:1的比例，而且屏幕上方还有刘海，所以很多软件并没有适配iPhone X，所以你在用一些熟悉的软件的时候 ，会感觉到特别不好，咦？怎么软件顶部的搜索框没有了呀？<br>    不过详细在iPhone X正式出货后，许多软件厂商会对iPhone X进行软件适配，毕竟这些用户的综合消费水平还是很高的，需要牢牢把握住。<br>    由于没有主页按钮，通过iOS操作需要一系列的滑动手势。在底部的一个部分滑动手指，可以在正在运行的应用程序之间切换，从屏幕底部向上滑动，手机会震动一下，并会显示所有当前正在运行的应用程序，手指只是向上滑动回到主屏幕。这些手势都需要用户的慢慢适应，谁让你把我的home按键去掉了呢？<br><img src="https://upload-images.jianshu.io/upload_images/1910724-ff1ae213a99e29a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br>    然有一个简单的方法，就是把虚拟home键功能开启就可以了，哈哈。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-55fc28d27c5598f4?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h3 id="面部解锁和表情包"><a href="#面部解锁和表情包" class="headerlink" title="面部解锁和表情包"></a>面部解锁和表情包</h3><p>当然iPhone X相对于iPhone 8系列包含两个功能，那就是：Face ID和Animoji。简单来说的话就是：Face ID用红外线摄像机代替了标准的iPhone指纹传感器，基本上将您的脸变成了您的密码。Animoji使用相同的相机系统将您的脸部动作映射到九个表情之一，以便您可以将表情说出来，并将其发送给朋友。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-7591724950481601?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br>    我花了不到20秒的过程登记了我的脸部ID ，然后开始尝试解锁手机，还好，每次都能完美解锁。整个过程与使用最近iPhone中的Touch ID传感器几乎一样快。更好的是，Face ID可以用于验证存储在钥匙串中的登录，并且我尝试使用Touch ID进行身份验证的每个应用程序现在都使用了我的脸，没有任何麻烦。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-6fc36c11c273e544?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br>    关于Animoji，我用我的脸录制了一个表情，你们看看吧，没错，我在卖萌。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-ff432170fa8d04a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p>在成像方面，背部的双摄像头与iPhone 8 Plus中的相机几乎相同。唯一真正的区别是，1200万像素的长焦相机具有更宽的光圈和光学防抖功能，因此在黑暗中放大的照片要看起来更好一些。所以说iPhone X相对于iPhone 8 Plus来说 夜景拍摄能力 要好一些。由于我没有来得及拍摄对比照片，所以现在，我不能的轻易下结论，后期会带给你们iPhone X 对比系列的相关测评，以及性能方面的测评，请持续关注我们。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-b73019bbb64db73e?imageMogr2/auto-orient/strip%7CimageView2/2/w/599" alt=""><br>    通过一天的体验来看，iPhone X给我的感觉还是不错的，未来苹果的iPhone新品 估计也会采用这种设计路线，我觉得iPhone X也值得被成为苹果面向未来设计的一款手机。</p><h4 id="Choose"><a href="#Choose" class="headerlink" title="Choose"></a>Choose</h4><p>关于颜色选择方面，我感觉黑色的更好看，你觉得呢？</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;在今年9月13日，iPhone发布十周年之际，苹果隆重推出了十周年纪念版，iPhone X。&lt;br&gt;苹果称这是一款面向未来的手机，那么这款手
      
    
    </summary>
    
      <category term="数码评测" scheme="http://datalearn.top/categories/%E6%95%B0%E7%A0%81%E8%AF%84%E6%B5%8B/"/>
    
    
      <category term="手机" scheme="http://datalearn.top/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>2017年上半年最值得购买的手机推荐(国产旗舰篇)</title>
    <link href="http://datalearn.top/2017/09/08/mobile01/"/>
    <id>http://datalearn.top/2017/09/08/mobile01/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2018-07-30T16:32:00.755Z</updated>
    
    <content type="html"><![CDATA[<p>2017年已经步入年底，各家手机厂商的产品也基本发布完毕，那么到底哪一款手机才是最适合我们的呢？<br>本文将带你盘点2017年最值得购买的手机，主要围绕国产2000元-3000元档的旗舰手机。后续也会出中端机和高端机系列，敬请关注。<br>本文主要综合手机性价比、综合性能和外观颜值三方面来考虑。</p><h4 id="1-华为荣耀9"><a href="#1-华为荣耀9" class="headerlink" title="1.华为荣耀9"></a>1.华为荣耀9</h4><h5 id="1-外观方面："><a href="#1-外观方面：" class="headerlink" title="1.外观方面："></a>1.外观方面：</h5><p>荣耀9在外观上正面采用2.5D弧面玻璃，前置指纹按键。背部采用15层3D曲面极光玻璃，在不同光线以及光线的不同照射角度上能够炫出变化的奇妙光泽，令机身背面拥有流光溢彩的光泽。而海鸥灰版本也是胡歌亲自参与调色的版本。<br>背部曲面玻璃的弧度被调整地比较贴合手掌，同时由于是玻璃材质，让荣耀9的背部手感比较温润。作为荣耀家族的颜值担当，外观设计整体是令人满意的。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-59f42a0ef7f6b71a.jpg" alt=""><br>机身左侧边框拥有SIM卡槽，右侧边框则为音量键和电源键，按键手感清脆，反馈很好。边框底部为3.5mm耳机接口、USB Type-C接口和单侧扬声器开孔，顶部则为降噪麦克风和红外发射器。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-44f6574d392715cf.jpg" alt=""><br>目前在售的机身颜色有：知更鸟蓝、海鸥灰、魅海蓝、琥珀金、幻夜黑五种颜色<br>小编比较倾向于知更鸟蓝和海鸥灰两种配色<br><img src="https://upload-images.jianshu.io/upload_images/1910724-26b87efb2a30526c.jpg" alt=""></p><h5 id="2-综合性能："><a href="#2-综合性能：" class="headerlink" title="2.综合性能："></a>2.综合性能：</h5><p>荣耀9配备了5.15英寸1080P的IPS LCD屏，后置纯平双摄像头，前置陶瓷指纹键，轻触敏锐点亮。<br>搭载自家的海思麒麟960处理器，性能上略逊于今年的旗舰标配：骁龙835处理器。<br>配EMUI5.1系统人工智能优化，号称500天久用不卡；电池容量3200mAh，配备Magic Live智慧功能继承+智慧融合导航，HUAWEI Pay支持北/上/广/深/苏州/武汉，手机秒变交通卡。<br>前置800万摄像头，后置1200万彩色+2000万黑白摄像头组合，支持2倍无损变焦和暗光夜拍，新增人像模式，前后摄像头均支持。<br>电池为3200mAh电池，支持9V/2A的快充规格。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-1869f66624075d50.jpg" alt=""></p><h5 id="3-售价方面："><a href="#3-售价方面：" class="headerlink" title="3.售价方面："></a>3.售价方面：</h5><p>4G+64G版本2299元</p><p>6G+64G版本2699元</p><p>6G+128G版本2999元</p><p>性价比价高，是今年值得购买的一款手机。</p><h4 id="2-一加5"><a href="#2-一加5" class="headerlink" title="2.一加5"></a>2.一加5</h4><h5 id="1-外观方面：-1"><a href="#1-外观方面：-1" class="headerlink" title="1.外观方面："></a>1.外观方面：</h5><p>一加5采用2.75 mm 视觉减薄侧边机身，第 5 代大猩猩 2.5D 玻璃覆 盖。采用全新油墨，更加一体深邃。看起来硬朗、优雅； 摸上去温润、舒适。外观上并没有太大亮点<br>目前在售的颜色有：月岩灰星辰黑和薄荷金三种配色。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-2a1debe6de69b61d.jpg" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-10424a6fdb40ba93.jpg" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-1223f1276afa4110.jpg" alt=""></p><h5 id="2-综合性能：-1"><a href="#2-综合性能：-1" class="headerlink" title="2.综合性能："></a>2.综合性能：</h5><p>一加5采用5.5英寸1080P分辨率全新 Optic AMOLED 屏幕，根据人眼观感对屏幕进行调试，看起来更舒适。新增 P3 广色域标准，让这块屏幕，显示更加出彩。<br>搭载高通骁龙835处理器，采用UFS2.1双通道闪存（数据读取、应用打开更快）<br>后置2000万+1600万像素高清双摄，f1.7大光圈，双核对焦。<br>支持Dash极速闪充，电池容量为3300mAh，<br>运行基于Android7.1.1的全新氢OS系统（全世界最流畅的安卓系统之一）<br><img src="https://upload-images.jianshu.io/upload_images/1910724-2e72083e852ae637.jpg" alt=""></p><h5 id="3-售价方面：-1"><a href="#3-售价方面：-1" class="headerlink" title="3.售价方面："></a>3.售价方面：</h5><p>6GB+64GB 2999元</p><p>8GB+128GB 3499元</p><p>综合来看一加5是目前国产手机拍照最好的手机，没有之一。也是目前最快的安卓手机。</p><h4 id="3-小米6"><a href="#3-小米6" class="headerlink" title="3.小米6"></a>3.小米6</h4><p><img src="https://upload-images.jianshu.io/upload_images/1910724-9dd17619c4a60d1f.jpg" alt=""></p><h5 id="1-外观方面"><a href="#1-外观方面" class="headerlink" title="1.外观方面"></a>1.外观方面</h5><p>小米6外观采用全新设计，手机采用了四曲面玻璃机身，号称40道工序打造，结合不锈钢高亮边框，整机看起来浑然一体、光彩四溢。<br>小米6拥有多种颜色，包括白色、蓝色、黑色，还尝试了亮银版，当然，由于良品率过低，亮银版仅仅在探索阶段，目前并未实现量产。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-fe6f92b4885d11c5.jpg" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-9ec8a00a3a42f83a.jpg" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-3728b8aa69568b8f.jpg" alt=""></p><h5 id="2-综合性能：-2"><a href="#2-综合性能：-2" class="headerlink" title="2.综合性能："></a>2.综合性能：</h5><p>小米6采用5.15英寸1080P显示屏，号称“更好用的护眼屏”，在有效减低蓝光的同时，更加接近真实的色彩，另外其最高亮度可达600nit，最低亮度可达1nit，支持4096级智能背光调节<br>小米6搭载高通骁龙835处理器，内置6GB内存。<br>小米6搭载后置双摄，由1200万像素长焦镜头和1200万像素广角镜头组成，适合用来拍人像，能够实现单反相机的背景虚化，支持微美颜，另外的重要特色则是支持2倍光学变焦、四轴光学防抖。<br>内置3350mAh电池，在四小时暴力续航测试之后，小米6还有剩余电量36%，雷军宣称小米6可以保持一天不用充电。<br>小米6的NFC进行了全面升级，支持多功能NFC，可当公交卡、银行卡使用，目前支持36家银行，支持微信、支付宝指纹使用。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-4657fec0582b9c3f.jpg" alt=""></p><h5 id="3-售价方面：-2"><a href="#3-售价方面：-2" class="headerlink" title="3.售价方面："></a>3.售价方面：</h5><p>4GB+64GB售价1999元（今年双11开卖）</p><p>6+64GB售价2499元</p><p>6+128GB售价2899元</p><p>陶瓷尊享版售价2999元</p><h5 id="3-1-小米note3"><a href="#3-1-小米note3" class="headerlink" title="3.1 小米note3"></a>3.1 小米note3</h5><p>今年小米还发布了小米note3,与小米6相比亮点就是增加了，通过人脸解锁手机的功能。<br>其余不同地方主要为：<br>处理器采用骁龙660，性能低于小米6<br>屏幕尺寸为5.5寸大于小米6的5.15寸<br>电池容量也要比小米6高上150mA<br><img src="https://upload-images.jianshu.io/upload_images/1910724-bb9b822050c56918.jpg" alt=""></p><h5 id="售价方面："><a href="#售价方面：" class="headerlink" title="售价方面："></a>售价方面：</h5><p>6+64GB售价2499元（亮蓝）<br>6+128GB售价2899元（亮黑）<br>6+128GB版售价2999元（亮蓝）<br>喜欢大屏的可以考虑小米note3，看重性能的可以选择小米6。</p><h4 id="4-一加3-3T"><a href="#4-一加3-3T" class="headerlink" title="4.一加3/3T"></a>4.一加3/3T</h4><p>如果资金紧张的同学对一加比较感兴趣，不妨可以考虑一加去年发布的旗舰手机一加3和一加3T。这两款手机在去年国内外的评价都很高。一加3 确实可以称得上是去年一加的诚意之作。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-4659233b88491c02.jpg" alt=""></p><h5 id="1-外观方面：-2"><a href="#1-外观方面：-2" class="headerlink" title="1.外观方面："></a>1.外观方面：</h5><p>一加3采用极窄边框设计，边框略经过弧形处理。背部是该机变化最大的地方，首先摄像头不再采用四四方方的设计，下面安置有一颗闪光灯，机身整体采用三段式设计，上下有两条天线条，另外这次一加采用了金属材质的后壳，表面经过阳极氧化处理，在手感和防沾染指纹方面应该有不错的表现。<br>目前在售的机身颜色有：<br>一加3：冰川灰和薄荷金<br><img src="https://upload-images.jianshu.io/upload_images/1910724-96fda02806e0dfc2.jpg" alt=""><br>一加3T：枪灰色、薄荷金和星辰黑<br><img src="https://upload-images.jianshu.io/upload_images/1910724-8ff545e5274f5e1d.jpg" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-3227929c9e8f9e34.jpg" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1910724-07f000882eec532c.jpg" alt=""></p><h5 id="2-综合性能：-3"><a href="#2-综合性能：-3" class="headerlink" title="2.综合性能："></a>2.综合性能：</h5><p>一加手机3采用了5.5英寸1080p分辨率AMOLED触控屏，采用大猩猩四代玻璃。</p><p>搭载标准版骁龙820处理器，拥有6GB LPDDR4大内存，内置64GB UFS 2.0闪存存储，但不支持存储卡扩展；</p><p>后置索尼IMX298 1600万像素镜头，支持光学防抖，前置800万像素镜头，高清美颜</p><p>电池容量则为3000毫安时，支持Dash闪充，号称30分钟充满60%，</p><p>网络方面则支持双卡双待全网通，其它方面，该机还支持NFC、USB Type-C。</p><p>一加手机3T采用5.5英寸1080P分辨率Optic AMOLED显示屏，采用大猩猩四代玻璃。</p><p>搭载主频2.35GHz高通骁龙821处理器，辅以6GB LPDDR4内存，64GB/128GB UFS 2.0存储空间，</p><p>主摄像头更换为1600万像素索尼IMX 298光学防抖传感器，前置镜头升级至1600万像素。</p><p>电池电量提升至3400mAh，支持Dash闪充技术。<br><img src="https://upload-images.jianshu.io/upload_images/1910724-2ce75f65521103c1.jpg" alt=""></p><h5 id="3-售价方面：-3"><a href="#3-售价方面：-3" class="headerlink" title="3.售价方面："></a>3.售价方面：</h5><p>一加3：6G+64G版本:1999元左右</p><p>一加3T：6G+64G版本2699元起步</p><p>一加3T：6G+128G版本3199元起步</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>外观颜值：小米6&gt;荣耀9&gt;一加5&gt;一加3/3T</p><p>综合性能：一加5&gt;小米6&gt;一加3T&gt;一加3&gt;荣耀9(结合安兔兔手机性能跑分排行榜)</p><p>拍照成像：一加5&gt;荣耀9&gt;小米6&gt;一加3/3T</p><p>性价比：小米6&gt;一加5&gt;荣耀9&gt;一加3/3T</p><p>最后，相信你已经知道自己想要购买哪款手机了，如果本文中没有合适的话，我们后期会推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年已经步入年底，各家手机厂商的产品也基本发布完毕，那么到底哪一款手机才是最适合我们的呢？&lt;br&gt;本文将带你盘点2017年最值得购买的手机，主要围绕国产2000元-3000元档的旗舰手机。后续也会出中端机和高端机系列，敬请关注。&lt;br&gt;本文主要综合手机性价比、综合性能
      
    
    </summary>
    
      <category term="数码评测" scheme="http://datalearn.top/categories/%E6%95%B0%E7%A0%81%E8%AF%84%E6%B5%8B/"/>
    
    
      <category term="手机" scheme="http://datalearn.top/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>前端开发神器：webstorm使用教程</title>
    <link href="http://datalearn.top/2017/02/08/webstorm/"/>
    <id>http://datalearn.top/2017/02/08/webstorm/</id>
    <published>2017-02-07T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:24.576Z</updated>
    
    <content type="html"><![CDATA[<p>WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。目前已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="http://www.jetbrains.com/webstorm/download/" target="_blank" rel="noopener">官网链接</a></p><h3 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h3><p>破解方法随着版本的更新，破解方法也有很多会失效<br>目前亲测有效的方法是：<br><img src="http://p3th9y4pk.bkt.clouddn.com/webstorm2.png" alt="webstorm2"><br>2018年3月15日更新：选择“license server” 输入：<code>http://idea.codebeta.cn</code><br><img src="http://p3th9y4pk.bkt.clouddn.com/webstorm1.png" alt="webstorm1"></p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>下面我整理一下webstorm的常用快捷键，希望自己在webstorm自己敲一下，体会一下webstorm的强大之处。<br>快速注释：<code>ctrl+/</code><br>快速整理代码：<code>CTRL+ALT+L</code><br>寻找函数或变量： <code>按住ctrl建+点击鼠标左键</code><br>代码大小写转换：<code>ctrl+shift+U</code><br>全局查找：<code>双击 shift</code><br>查找最近打开的文件：<code>双击shift</code><br>生成HTML标准文档：<code>！+tab</code>（这个功能很好用）<br>重构-重命名文件项目：<code>shift+F6</code><br>复制行：<code>ctrl+D</code><br>查找行：<code>ctrl+G</code><br>代码向上/下移动：<code>Ctrl+Shift+Up/Down</code><br>高亮错误或警告快速定位：<code>F2 或Shift+F2</code><br>高亮显示所有该文本，按Esc高亮消失：选中文本，<code>Ctrl+Shift+F7</code><br>跳转方法实现处：<code>Ctrl + Alt +鼠标左键</code><br>替换文本：<code>ctrl+R</code><br>查找文本：<code>ctrl+F</code><br>方法参数提示：<code>ctrl+P</code><br>最近打开的文件：<code>ctrl+E</code><br>通过文件名快速查找工程内的文件：<code>ctrl+Shift+N</code><br>重新开始一行（无论光标在哪个位置）：<code>Shift+enter</code><br>快速生成<code>&lt;h1&gt;&lt;/h1&gt;</code>快捷:<code>h1+tab</code><br>快速生成<code>&lt;div id=&quot;abc&quot;&gt;&lt;/div&gt;</code>快捷：<code>div#abc+tab</code> 或者<code>#abc+tab</code><br>快速生成div里面有6个P标签快捷：<code>div&gt;p*6 ,按Tab键</code><br>快速生成链接标签<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code>快捷：<code>a[href=#]</code><br>快速生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;menu&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>快捷：<code>ul.menu&gt;li*6&gt;a[href=#]{HTML}：</code><br>当然还有很多快捷方式，我这边只是整理一部分比较常用的而已，webstorm的强大之处不止于此。</p><h3 id="常用插件推荐"><a href="#常用插件推荐" class="headerlink" title="常用插件推荐"></a>常用插件推荐</h3><p>插件在设置里选择plugins就可以了<br><img src="http://p3th9y4pk.bkt.clouddn.com/webstorm3.png" alt="webstorm3"><br>webstorm里面插件丰富，根据自己的需要选择下载就可以了。<br>像我下载的支持markdown功能的插件：<br><img src="http://p3th9y4pk.bkt.clouddn.com/webstorm4.png" alt="webstorm4"><br>还有支持vue.js的插件：<br><img src="http://p3th9y4pk.bkt.clouddn.com/webstorm5.png" alt="webstorm5"><br>webstorm主题设置推荐<br>webstorm还有一个强大的特色功能就是可以定制和更改主题<br>给大家推荐两个网站，上面有各种各样的主题可以下载<br><a href="http://www.webstormthemes.com/" target="_blank" rel="noopener">webstormthemes</a><br><a href="http://color-themes.com/" target="_blank" rel="noopener">color-themes</a><br>那么主题下载下来如何使用呢？<br><img src="http://p3th9y4pk.bkt.clouddn.com/webstorm6.png" alt="webstorm6"><br>点击文件—导入设置–选择下载下来的jar包就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。目前已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ ID
      
    
    </summary>
    
      <category term="软件推荐" scheme="http://datalearn.top/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="软件" scheme="http://datalearn.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTML5教程：文件上传下载</title>
    <link href="http://datalearn.top/2017/02/08/html501/"/>
    <id>http://datalearn.top/2017/02/08/html501/</id>
    <published>2017-02-07T16:00:00.000Z</published>
    <updated>2018-07-30T16:31:15.553Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5 中提供的文件API在前端中有着丰富的应用，上传、下载、读取内容等在日常的交互中很常见。而且在各个浏览器的兼容也比较好，包括移动端，除了 IE 只支持 IE10 以上的版本。想要更好地掌握好操作文件的功能，先要熟悉每个API。</p><h4 id="FileList-对象和-file-对象"><a href="#FileList-对象和-file-对象" class="headerlink" title="FileList 对象和 file 对象"></a>FileList 对象和 file 对象</h4><p>HTML 中的 input[type=”file”] 标签有个 multiple 属性，允许用户选择多个文件，FileList对象则就是表示用户选择的文件列表。这个列表中的每一个文件，就是一个 file 对象。<br>file 对象的属性：<br>• name : 文件名，不包含路径。<br>• type : 文件类型。图片类型的文件都会以 image/ 开头，可以由此来限制只允许上传图片。<br>• size : 文件大小。可以根据文件大小来进行其他操作。<br>• lastModified : 文件最后修改的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; id=&quot;files&quot; multiple&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var elem = document.getElementById(&apos;files&apos;);</span><br><span class="line">elem.onchange = function (event) &#123;</span><br><span class="line">var files = event.target.files;</span><br><span class="line">for (var i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">// 文件类型为 image 并且文件大小小于 200kb</span><br><span class="line">if(files[i].type.indexOf(&apos;image/&apos;) !== -1 &amp;&amp; files[i].size &lt; 204800)&#123;</span><br><span class="line">console.log(files[i].name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>input 中有个 accept 属性，可以用来规定能够通过文件上传进行提交的文件类型。<br>accept=”image/<em>“ 可以用来限制只允许上传图像格式。但是在 Webkit 浏览器下却出现了响应滞慢的问题，要等上好几秒才弹出文件选择框。<br>解决方法就是将 </em> 通配符改为指定的 MIME 类型。<br><code>&lt;input type=&quot;file&quot; accept=&quot;image/gif,image/jpeg,image/jpg,image/png&quot;&gt;</code></p><h4 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h4><p>Blob 对象相当于一个容器，可以用于存放二进制数据。它有两个属性，size 属性表示字节长度，type 属性表示 MIME 类型。<br>如何创建<br>Blob 对象可以使用 Blob() 构造函数来创建。<br><code>var blob = new Blob([&#39;hello&#39;], {type:&quot;text/plain&quot;});</code><br>Blob 构造函数中的第一个参数是一个数组，可以存放 ArrayBuffer对象、ArrayBufferView 对象、Blob对象和字符串。<br>Blob 对象可以通过 slice() 方法来返回一个新的 Blob 对象。<br><code>var newblob = blob.slice(0,5, {type:&quot;text/plain&quot;});</code><br>slice() 方法使用三个参数，均为可选。第一个参数代表要从Blob对象中的二进制数据的起始位置开始复制，第二个参数代表复制的结束位置，第三个参数为 Blob 对象的 MIME 类型。<br>canvas.toBlob() 也可以创建 Blob 对象。toBlob() 使用三个参数，第一个为回调函数，第二个为图片类型，默认为 image/png，第三个为图片质量，值在0到1之间。<br><code>var canvas = document.getElementById(&#39;canvas&#39;);canvas.toBlob(function(blob){ console.log(blob); }, &quot;image/jpeg&quot;, 0.5);</code></p><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p>Blod 对象可以通过 window.URL 对象生成一个网络地址，结合 a 标签的 download 属性来实现下载文件功能。<br>比如把 canvas 下载为一个图片文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">canvas.toBlob(function(blob)&#123;</span><br><span class="line">// 使用 createObjectURL 生成地址，格式为 blob:null/fd95b806-db11-4f98-b2ce-5eb16b38ba36</span><br><span class="line">var url = URL.createObjectURL(blob);</span><br><span class="line">var a = document.createElement(&apos;a&apos;);</span><br><span class="line">a.download = &apos;canvas&apos;;</span><br><span class="line">a.href = url;</span><br><span class="line"></span><br><span class="line">// 模拟a标签点击进行下载</span><br><span class="line">a.click();</span><br><span class="line">// 下载后告诉浏览器不再需要保持这个文件的引用了</span><br><span class="line">URL.revokeObjectURL(url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以将字符串保存为一个文本文件，方法类似。</p><h4 id="FileReader-对象"><a href="#FileReader-对象" class="headerlink" title="FileReader 对象"></a>FileReader 对象</h4><p>FileReader 对象主要用来把文件读入内存，并且读取文件中的数据。通过构造函数创建一个 FileReader 对象<br><code>var reader = new FileReader();</code><br>该对象有以下方法：<br>• abort：中断读取操作。<br>• readAsArrayBuffer：读取文件内容到ArrayBuffer对象中。<br>• readAsBinaryString：将文件读取为二进制数据。<br>• readAsDataURL：将文件读取为data: URL格式的字符串。<br>• readAsText：将文件读取为文本。</p><h4 id="上传图片预览"><a href="#上传图片预览" class="headerlink" title="上传图片预览"></a>上传图片预览</h4><p>在常见的应用就是在客户端上传图片之后通过 readAsDataURL() 来显示图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; id=&quot;files&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;</span><br><span class="line">&lt;img src=&quot;blank.gif&quot; id=&quot;preview&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var elem = document.getElementById(&apos;files&apos;),</span><br><span class="line">img = document.getElementById(&apos;preview&apos;);</span><br><span class="line">elem.onchange = function () &#123;</span><br><span class="line">var files = elem.files,</span><br><span class="line">reader = new FileReader();</span><br><span class="line">if(files &amp;&amp; files[0])&#123;</span><br><span class="line">reader.onload = function (ev) &#123;</span><br><span class="line">img.src = ev.target.result;</span><br><span class="line">&#125;</span><br><span class="line">reader.readAsDataURL(files[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是在一些手机上竖着拍照上传照片时会有bug，会发现照片倒了，包括三星和iPhone。。。解决方案这里不做讲解，有兴趣可以查看：<a href="https://github.com/lin-xin/blog/issues/18" target="_blank" rel="noopener">移动端图片上传旋转、压缩的解决方案</a></p><h4 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h4><p>FileReader 对象的 readAsText() 可以读取文件的文本，结合 Blob 对象下载文件的功能，那就可以实现将数据导出文件备份到本地，当数据要恢复时，通过 input 把备份文件上传，使用 readAsText() 读取文本，恢复数据。<br>代码跟上面功能类似，这里不重复，具体的应用可以参考：<a href="https://github.com/lin-xin/notepad" target="_blank" rel="noopener">notepad</a></p><h4 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h4><p>在 HTML5 中新增了 atob 和 btoa 方法来支持 Base64 编码。它们的命名也很简单，b to a 和 a to b，即代表着编码和解码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;https://lin-xin.github.io&quot;;</span><br><span class="line">var b = btoa(a);</span><br><span class="line">var c = atob(b);</span><br><span class="line">console.log(a); // https://lin-xin.github.io</span><br><span class="line">console.log(b); // aHR0cHM6Ly9saW4teGluLmdpdGh1Yi5pbw==</span><br><span class="line">console.log(c); // https://lin-xin.github.io</span><br></pre></td></tr></table></figure><p>btoa 方法对字符串 a 进行编码，不会改变 a 的值，返回一个编码后的值。<br>atob 方法对编码后的字符串进行解码。<br>但是参数中带中文，已经超出了8位ASCII编码的字符范围，浏览器就会报错。所以需要先对中文进行 encodeURIComponent 编码处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;哈喽 世界&quot;;</span><br><span class="line">var b = btoa(encodeURIComponent(a));</span><br><span class="line">var c = decodeURIComponent(atob(b));</span><br><span class="line">console.log(b); // JUU1JTkzJTg4JUU1JTk2JUJEJTIwJUU0JUI4JTk2JUU3JTk1JThD</span><br><span class="line">console.log(c); // 哈喽 世界</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML5 中提供的文件API在前端中有着丰富的应用，上传、下载、读取内容等在日常的交互中很常见。而且在各个浏览器的兼容也比较好，包括移动端，除了 IE 只支持 IE10 以上的版本。想要更好地掌握好操作文件的功能，先要熟悉每个API。&lt;/p&gt;
&lt;h4 id=&quot;FileLi
      
    
    </summary>
    
      <category term="编程技术" scheme="http://datalearn.top/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://datalearn.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发" scheme="http://datalearn.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
